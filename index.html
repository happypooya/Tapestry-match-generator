  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Tapestry Matchup Tracker</title>
      <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&family=Fira+Sans&family=Inter&display=swap" rel="stylesheet">
      <style>
          /* Basic body styling with background image */
          body {
              /* Replace with your desired background image URL */
              background-image: url('https://cf.geekdo-images.com/7kqDmkUMGxXHr1wNPA7Gvg__original/img/e6rS0PyrVlPpJjCsWPmCaGg9PXc=/0x0/filters:format(jpeg)/pic4884996.jpg');
              background-size: cover; /* Cover the entire viewport */
              background-position: center; /* Center the image */
              background-repeat: no-repeat; /* Do not repeat the image */
              background-attachment: fixed; /* Keep image fixed when scrolling */
              padding: 2em;
              color: #2d3436;
              font-family: 'Inter', sans-serif;
              margin: 0; /* Reset default body margin */
              padding-top: 120px; /* Space for the game cover image */
              position: relative; /* Needed for z-index on game cover */
          }

          /* Semi-transparent overlay for readability */
          body::before {
              content: '';
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background-color: rgba(248, 249, 250, 0.8); /* Light semi-transparent overlay */
              z-index: -2; /* Below content, above background image */
          }


          /* Game cover image positioning */
          .game-cover {
              position: absolute;
              top: 10px;
              left: 10px;
              height: 100px; /* Fixed height */
              width: auto; /* Maintain aspect ratio */
              margin: 0;
              z-index: 2; /* Ensure it's above the panel */
              border: 3px solid #fff; /* Add a white border */
              box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Add shadow */
          }

          #gameCover {
              height: 100%;
              width: auto;
              max-width: 150px; /* Max width for the image */
              border-radius: 8px; /* Slightly smaller border-radius */
              display: block; /* Remove extra space below image */
          }

          /* Main content panel */
          .panel {
              background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white */
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Stronger shadow */
              padding: 1.5em;
              margin: 0 auto; /* Center the panel */
              max-width: 900px;
              position: relative; /* Ensure panel content is above game cover */
              z-index: 1;
              display: flex; /* Use flexbox for overall layout */
              flex-direction: column; /* Stack children vertically */
              gap: 1.5em; /* Add space between sections */
          }

          /* Headings */
          h1, h2 {
              font-family: 'Playfair Display', serif;
              color: #34495e; /* Darker blue-grey */
              text-align: center; /* Center headings */
              margin-bottom: 0.5em; /* Space below headings */
          }

          h1 {
              margin-top: 0; /* Remove top margin for the main title */
              color: #2c3e50; /* Even darker for main title */
          }

          h3 {
              font-family: 'Playfair Display', serif;
              color: #34495e;
              margin-top: 1em;
              margin-bottom: 0.5em;
              text-align: center;
          }


          /* Section styling */
          .section {
              background-color: rgba(248, 249, 250, 0.7); /* More transparent light background */
              border-radius: 6px;
              padding: 1em;
              border: 1px solid #e9ecef; /* Subtle border */
              box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); /* Inner shadow */
          }


          /* Current match display */
          .match-panel {
              margin: 0.5em 0; /* Adjusted margin */
              font-size: 1.4em; /* Slightly larger font */
              text-align: center; /* Center the match text */
              padding: 0.6em; /* Add padding */
              background-color: rgba(233, 236, 239, 0.8); /* More transparent light background */
              border-radius: 4px;
              font-weight: bold;
          }

          .civ {
              font-family: 'Playfair Display', serif;
              font-weight: bold;
              color: #2c3e50; /* Darker blue-grey */
          }

          .mat {
              font-family: 'Fira Sans', sans-serif;
              font-style: italic;
              color: #1abc9c; /* Teal color */
          }

          /* Score input area */
          .score-inputs {
              display: flex;
              flex-direction: column;
              gap: 0.8em; /* Increased gap */
              margin-bottom: 1em;
              align-items: center; /* Center inputs */
          }

          .score-inputs > div { /* Target the direct children divs */
              display: flex;
              align-items: center;
              gap: 0.8em; /* Increased gap between input+buttons groups */
              flex-wrap: wrap; /* Allow items to wrap */
              justify-content: center; /* Center items horizontally */
          }

          input[type="number"] {
              width: 90px; /* Adjusted width */
              padding: 0.6em; /* Adjusted padding */
              border: 1px solid #ced4da; /* Subtle border */
              border-radius: 4px;
              font-size: 1em;
              background-color: #ffffff; /* White background for input */
              text-align: center; /* Center text in number input */
          }

           /* Container for vertical score buttons */
           .score-button-group {
               display: flex;
               flex-direction: column; /* Stack buttons vertically */
               margin-left: 0.4em; /* Space to the left of the button group */
           }

           /* Score button styling */
           .score-button {
               padding: 0.2em 0.8em; /* Smaller padding for score buttons */
               border: none;
               color: white;
               cursor: pointer;
               font-size: 0.9em; /* Smaller font size */
               transition: background-color 0.3s ease, transform 0.1s ease;
               box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Smaller shadow */
               text-align: center; /* Center text in button */
               min-width: 45px; /* Increased min-width for text */
           }

           .score-button.add {
               background-color: #2ecc71; /* Green for add */
               border-top-left-radius: 4px; /* Rounded top corners */
               border-top-right-radius: 4px;
               border-bottom: 1px solid rgba(0,0,0,0.1); /* Small border between + and - */
           }

           .score-button.subtract {
               background-color: #e74c3c; /* Red for subtract */
               border-bottom-left-radius: 4px; /* Rounded bottom corners */
               border-bottom-right-radius: 4px;
           }


           .score-button:hover {
               opacity: 0.9; /* Slight opacity change on hover */
           }

           .score-button:active {
               transform: scale(0.95); /* Slightly shrink when pressed */
               box-shadow: 0 0px 2px rgba(0,0,0,0.1);
           }


          /* Buttons */
          .button-group {
              display: flex;
              justify-content: center; /* Center buttons */
              gap: 1em;
              margin-top: 1em; /* Space above button group */
              flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
          }

          button {
              padding: 0.7em 1.2em; /* Adjusted padding */
              border: none;
              color: white;
              cursor: pointer;
              border-radius: 4px;
              font-size: 1em;
              transition: background-color 0.3s ease, transform 0.1s ease; /* Smooth hover and active effect */
              box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Button shadow */
          }

          button:hover {
              opacity: 0.9; /* Slight opacity change on hover */
          }

          button:active {
              transform: scale(0.98); /* Slightly shrink when pressed */
              box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Smaller shadow when pressed */
          }

           /* Specific button styling for better grouping */
           #generateMatchButton {
               background-color: #2ecc71; /* Emerald green */
           }
           #generateMatchButton:hover {
               background-color: #27ae60;
           }

           #submitScoreButton {
               background-color: #3498db; /* Peter River blue */
           }
            #submitScoreButton:hover {
               background-color: #2980b9;
           }

           #undoButton {
               background-color: #f1c40f; /* Sunflower yellow */
               color: #2d3436; /* Dark text for visibility */
           }
            #undoButton:hover {
               background-color: #f39c12;
           }

           #resetButton {
               background-color: #dc3545; /* Alizarin red */
           }
            #resetButton:hover {
               background-color: #c0392b;
           }

            #createManualMatchButton {
                background-color: #9b59b6; /* Amethyst purple */
            }
             #createManualMatchButton:hover {
                background-color: #8e44ad;
            }

            #howItWorksButton {
                background-color: #7f8c8d; /* Gray */
            }
            #howItWorksButton:hover {
                background-color: #95a5a6;
            }


           /* Manual Select Inputs */
           .manual-selects {
               display: flex;
               flex-direction: column;
               gap: 0.8em;
               margin-bottom: 1em;
               align-items: center;
           }

           .manual-selects div {
               display: flex;
               align-items: center;
               gap: 0.5em;
               flex-wrap: wrap; /* Allow items to wrap */
               justify-content: center;
           }

           .manual-selects label {
               font-weight: bold;
               margin-right: 0.5em;
           }

           .manual-selects select {
               padding: 0.5em;
               border: 1px solid #ced4da;
               border-radius: 4px;
               font-size: 1em;
               background-color: #ffffff;
           }

           /* Specific message area for random generate button */
           #generateMessage {
               text-align: center;
               margin-top: 0.5em;
               font-style: italic;
               color: #555;
           }

           /* Tie-breaker section */
           .tie-breaker-section {
               display: none; /* Hidden by default */
               flex-direction: column;
               align-items: center;
               gap: 1em;
               margin-top: 1.5em;
               padding: 1em;
               background-color: rgba(255, 236, 179, 0.8); /* Light orange background */
               border: 1px solid rgba(253, 203, 110, 0.8);
               border-radius: 6px;
           }

           .tie-breaker-section h3 {
               margin: 0;
               color: #e67e22; /* Dark orange */
           }

           .tie-breaker-buttons {
               display: flex;
               gap: 1em;
               flex-wrap: wrap;
               justify-content: center;
           }

           .tie-breaker-buttons button {
               background-color: #f39c12; /* Orange */
           }
            .tie-breaker-buttons button:hover {
                background-color: #e67e22;
            }


          /* Scoreboard tables */
          .scoreboard-table {
              border-collapse: collapse;
              width: 100%;
              margin-top: 1em; /* Adjusted margin */
              box-shadow: 0 1px 4px rgba(0,0,0,0.08); /* Added subtle shadow */
          }

          .scoreboard-table th, .scoreboard-table td {
              border: 1px solid #dee2e6; /* Lighter border */
              padding: 0.8em; /* Adjusted padding */
              text-align: center;
          }

          .scoreboard-table th {
              background-color: #e9ecef; /* Header background */
              font-weight: bold;
              color: #495057;
          }

          .scoreboard-table tbody tr:nth-child(odd) {
              background-color: rgba(248, 249, 250, 0.6); /* Zebra striping with transparency */
          }

          .scoreboard-table tbody tr:hover {
              background-color: rgba(226, 230, 234, 0.7); /* Hover effect with transparency */
          }

          /* Podium styling for top 3 */
          .scoreboard-table tbody tr:nth-child(1) td {
              background: gold;
              font-weight: bold;
          }

          .scoreboard-table tbody tr:nth-child(2) td {
              background: silver;
              font-weight: bold;
          }

          .scoreboard-table tbody tr:nth-child(3) td {
              background: #cd7f32; /* Bronze */
              font-weight: bold;
          }

          /* Match History List */
          #matchHistory {
              list-style: none; /* Remove default list bullets/numbers */
              padding: 0;
              margin-top: 1em;
              max-height: 200px; /* Limit height and add scroll */
              overflow-y: auto;
              border: 1px solid #ced4da; /* Subtle border */
              border-radius: 4px;
              background-color: rgba(255, 255, 255, 0.7); /* White background with transparency */
              box-shadow: 0 2px 6px rgba(0,0,0,0.08); /* Add a subtle shadow to the list */
          }

          #matchHistory li {
              padding: 0.8em 1.2em; /* Increased padding */
              border-bottom: 1px solid #e9ecef; /* Lighter border */
              font-size: 0.95em;
              display: flex; /* Use flexbox for layout within list item */
              justify-content: space-between; /* Space out number/details and date */
              align-items: center; /* Vertically align items */
              background-color: rgba(255, 255, 255, 0.9); /* Slightly more opaque background */
              transition: background-color 0.2s ease; /* Smooth hover transition */
          }

           #matchHistory li:nth-child(odd) {
               background-color: rgba(248, 249, 250, 0.8); /* Subtle zebra striping */
           }

          #matchHistory li:last-child {
              border-bottom: none;
          }

           #matchHistory li:hover {
               background-color: rgba(226, 230, 234, 0.9); /* Highlight on hover */
           }

          .match-winner {
              font-weight: bold;
              color: #2c3e50; /* Darker color for winner */
          }

           .match-history-date {
               font-size: 1em; /* Increased font size */
               color: #555; /* Slightly darker color for better visibility */
               margin-left: 1em; /* Space between match details and date */
               flex-shrink: 0; /* Prevent date from shrinking */
               font-weight: bold; /* Make date bold */
           }

           .match-history-details {
               flex-grow: 1; /* Allow match details to take available space */
               text-align: left; /* Align match details to the left */
               margin-right: 1em; /* Space between details and date */
           }

           .match-number {
               font-weight: bold;
               margin-right: 0.8em; /* Space after the number */
               color: #34495e; /* Darker color for the number */
           }


          /* Message Box */
          #messageBox {
              margin-top: 1em;
              padding: 1em; /* Increased padding */
              background-color: #d4edda; /* Light green for info */
              border: 1px solid #c3e6cb; /* Darker green border */
              color: #155724; /* Dark green text */
              border-radius: 8px; /* More rounded corners */
              text-align: left; /* Align text left */
              display: none; /* Hidden by default */
              font-weight: normal; /* Normal font weight */
              cursor: pointer; /* Indicate it's clickable */
              transition: background-color 0.3s ease; /* Smooth transition */
              white-space: pre-wrap; /* Preserve line breaks */
          }

          #messageBox:hover {
              background-color: #c8e5d0; /* Slightly darker green on hover */
          }


          /* Fireworks Canvas */
          #fireworksCanvas {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: 5; /* Above general content, below modal text */
              pointer-events: none; /* Allow clicks to pass through to elements below */
              display: none; /* Hidden by default */
          }

          /* High Score Text Overlay */
          #highScoreOverlayText {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              z-index: 6; /* Above canvas */
              color: white; /* White text for contrast */
              font-family: 'Playfair Display', serif;
              font-size: 3em; /* Large font size */
              text-shadow: 2px 2px 8px rgba(0,0,0,0.8); /* Text shadow for readability */
              text-align: center;
              pointer-events: none; /* Allow clicks to pass through */
              display: none; /* Hidden by default */
          }

          /* Custom Confirmation Modal */
          .custom-modal-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black overlay */
              display: flex;
              justify-content: center;
              align-items: center;
              z-index: 10; /* Above other content */
              display: none; /* Hidden by default */
          }

          .custom-modal {
              background-color: #fff;
              padding: 2em;
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.2);
              text-align: center;
              max-width: 400px;
              width: 90%; /* Responsive width */
          }

          .custom-modal p {
              margin-bottom: 1.5em;
              font-size: 1.1em;
              color: #333;
              text-align: left; /* Align text left for readability */
              white-space: pre-wrap; /* Preserve line breaks */
          }

          .custom-modal .button-group {
              margin-top: 0; /* Remove top margin as it's in the modal */
          }

          .custom-modal button {
              padding: 0.8em 1.5em;
          }

           .custom-modal .confirm-button {
               background-color: #3498db; /* Blue */
           }
            .custom-modal .confirm-button:hover {
               background-color: #2980b9;
           }

           .custom-modal .cancel-button {
               background-color: #e74c3c; /* Red */
           }
            .custom-modal .cancel-button:hover {
               background-color: #c0392b;
           }

           /* Style for the single OK/Close button in the modal */
           .custom-modal .single-button {
               background-color: #3498db; /* Blue */
               margin-top: 1em; /* Add space above the button */
           }
            .custom-modal .single-button:hover {
                background-color: #2980b9;
            }


          /* Responsive adjustments */
          @media (max-width: 768px) { /* Adjusted breakpoint for better tablet view */
               body {
                   padding: 1em;
                   padding-top: 110px; /* Adjust for smaller game cover */
               }

               .panel {
                   padding: 1em;
                   gap: 1em;
               }

               .score-inputs > div { /* Target the direct children divs */
                   flex-direction: column; /* Stack score inputs vertically */
                   gap: 0.5em;
               }

               .button-group {
                   flex-direction: column;
                   gap: 0.8em;
               }

               button {
                   width: 100%; /* Full width buttons on smaller screens */
                   padding: 0.8em;
               }

               .game-cover {
                   height: 80px; /* Smaller game cover */
               }

               #gameCover {
                   max-width: 100px;
               }

               body {
                   padding-top: 100px; /* Adjust padding-top */
               }

               .scoreboard-table th, .scoreboard-table td {
                   padding: 0.6em; /* Smaller padding in tables */
                   font-size: 0.9em;
               }

               #highScoreOverlayText {
                   font-size: 2em; /* Smaller font on tablets */
               }

               .manual-selects div {
                   flex-direction: column; /* Stack selects vertically */
                   gap: 0.5em;
               }

               #matchHistory li {
                   flex-direction: column; /* Stack date and details vertically */
                   align-items: flex-start; /* Align items to the start */
               }

               .match-history-date {
                   margin-bottom: 0.5em; /* Space below date */
                   margin-right: 0; /* Remove right margin */
                   margin-left: 0; /* Remove left margin */
               }

                .match-history-details {
                    margin-right: 0; /* Remove right margin */
                }
          }

           @media (max-width: 480px) { /* Even smaller screens */
               body {
                   padding: 0.5em;
                   padding-top: 90px;
               }

               .panel {
                   padding: 0.8em;
               }

               .game-cover {
                   height: 70px;
               }

               #gameCover {
                   max-width: 80px;
               }

                h1 { font-size: 1.5em; }
                h2 { font-size: 1.2em; }

                .match-panel { font-size: 1.2em; }

                #highScoreOverlayText {
                   font-size: 1.5em; /* Even smaller font on phones */
               }
           }

            /* Styling for the Select Mode dropdown */
            #gameModeSelect {
                padding: 0.5em;
                border: 1px solid #ced4da;
                border-radius: 4px;
                font-size: 1em;
                background-color: #ffffff;
                font-family: 'Inter', sans-serif; /* Match app font */
                color: #2d3436; /* Match app text color */
                cursor: pointer;
            }

            #gameModeSelect:hover {
                 border-color: #a0aec0; /* Subtle hover effect */
            }

            #gameModeSelect:focus {
                 outline: none;
                 border-color: #3498db; /* Highlight on focus */
                 box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25); /* Add a subtle focus shadow */
            }

            /* Style for the Select Mode label to match h2 */
            .select-mode-label {
                font-family: 'Playfair Display', serif;
                color: #34495e; /* Darker blue-grey */
                font-weight: bold; /* Match h2 font weight */
                margin-right: 0.5em; /* Keep some space between label and select */
                font-size: 1.4em; /* Match Current Match font size */
            }

            /* Style for the container holding the Select Mode label and select */
            .select-mode-container {
                display: flex;
                align-items: center;
                justify-content: center; /* Center content horizontally */
                padding: 0.6em; /* Match Current Match padding */
                margin: 0.5em 0; /* Match Current Match margin */
                background-color: rgba(233, 236, 239, 0.8); /* Match Current Match background */
                border-radius: 4px; /* Match Current Match border-radius */
            }


            /* Center the select mode section content */
            .section .button-group > div:first-child {
                text-align: center; /* Center the label and select */
                width: 100%; /* Allow it to take full width for centering */
            }

            /* Remove the space-between from the button-group in the select mode section */
            .section .button-group {
                justify-content: center;
            }


      </style>
  </head>
  <body>

      <div class="game-cover">
          <img id="gameCover" src="https://cf.geekdo-images.com/7kqDmkUMGxXHr1wNPA7Gvg__original/img/e6rS0PyrVlPpJjCsWPmCaGg9PXc=/0x0/filters:format(jpeg)/pic4884996.jpg" alt="Tapestry Board Game Cover">
      </div>

      <div class="panel">
          <h1>Tapestry Matchup Tracker</h1>

          <div class="section">
               <div class="button-group">
                   <div class="select-mode-container"> <label for="gameModeSelect" class="select-mode-label">Select Mode:</label>
                       <select id="gameModeSelect">
                           <option value="pvp">Player vs Player</option>
                           <option value="automa">Player vs Automa</option>
                       </select>
                   </div>
               </div>
          </div>


          <div class="section">
              <h2>Current Match</h2>
              <div id="currentMatch" class="match-panel">
                  Select or Generate a match below!
              </div>
          </div>

          <div class="section">
              <h2>Generate Random Match</h2>
              <div class="button-group">
                  <button id="generateMatchButton">Generate Random Match</button>
              </div>
              <div id="generateMessage"></div> </div>

           <div class="section">
               <h2>Create Manual Match</h2>
               <div class="manual-selects">
                   <div>
                       <label for="civSelectA">Team A Civ:</label>
                       <select id="civSelectA"></select>
                       <label for="matSelectA">City Mat:</label>
                       <select id="matSelectA"></select>
                   </div>
                   <div>
                       <label for="civSelectB">Team B Civ:</label>
                       <select id="civSelectB"></select>
                       <label for="matSelectB">City Mat:</label>
                       <select id="matSelectB"></select>
                   </div>
               </div>
               <div class="button-group">
                   <button id="createManualMatchButton">Create Manual Match</button>
               </div>
           </div>


          <div class="section">
              <h2>Enter Scores</h2>
              <div class="score-inputs">
                  <div>
                      <label id="teamALabel" for="scoreA">Score for Team A:</label>
                      <input type="number" id="scoreA" min="0">
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="100" data-operation="add">+100</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="100" data-operation="subtract">-100</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="50" data-operation="add">+50</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="50" data-operation="subtract">-50</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="10" data-operation="add">+10</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="10" data-operation="subtract">-10</button>
                      </div>
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="1" data-operation="add">+1</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="1" data-operation="subtract">-1</button>
                      </div>
                  </div>
                  <div>
                      <label id="teamBLabel" for="scoreB">Score for Team B:</label>
                      <input type="number" id="scoreB" min="0">
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="100" data-operation="add">+100</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="100" data-operation="subtract">-100</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="50" data-operation="add">+50</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="50" data-operation="subtract">-50</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="10" data-operation="add">+10</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="10" data-operation="subtract">-10</button>
                      </div>
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="1" data-operation="add">+1</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="1" data-operation="subtract">-1</button>
                      </div>
                  </div>
              </div>
              <div class="button-group">
                   <button id="submitScoreButton">Submit Score</button>
              </div>
               <div id="tieBreakerSection" class="tie-breaker-section">
                  <h3>Tie-breaker: Who won?</h3>
                  <div id="tieBreakerButtons" class="tie-breaker-buttons">
                      </div>
              </div>
          </div>

           <div id="messageBox" role="alert"></div>


          <div class="section">
               <h2>History and Options</h2>
               <div class="button-group">
                   <button id="undoButton">Undo Last Match</button>
                   <button id="resetButton">Reset All</button>
                   </div>
               <h3>Match History</h3>
               <ol id="matchHistory">
                   </ol>
          </div>


          <div class="section">
              <h2>Civilization Standings</h2>
              <table id="civTable" class="scoreboard-table">
                  <thead>
                      <tr>
                          <th>Civilization</th>
                          <th>Games Played</th>
                          <th>Points</th>
                          <th>Total Score</th>
                      </tr>
                  </thead>
                  <tbody>
                      </tbody>
              </table>
          </div>

          <div class="section">
              <h2>City Mat Standings</h2>
              <table id="matTable" class="scoreboard-table">
                  <thead>
                      <tr>
                          <th>City Mat</th>
                          <th>Games Played</th>
                          <th>Points</th>
                          <th>Total Score</th>
                      </tr>
                  </thead>
                  <tbody>
                      </tbody>
              </table>
          </div>
      </div>

      <canvas id="fireworksCanvas"></canvas>

      <div id="highScoreOverlayText"></div>

      <div id="customConfirmModal" class="custom-modal-overlay">
          <div class="custom-modal">
              <p id="customConfirmMessage"></p>
              <div class="button-group">
                  <button id="customConfirmOK" class="confirm-button">OK</button>
                  <button id="customConfirmCancel" class="cancel-button">Cancel</button>
              </div>
               <button id="customModalClose" class="single-button" style="display: none;">Close</button>
          </div>
      </div>


      <script>
          // Array of Tapestry Civilizations
          const civs = [
              "Adventurers", "Alchemists", "Aliens", "Architects", "Artificiers", "Celestials", "Collectors", "Crafters",
              "Elder Ones", "Entertainers", "Faefolk", "Followers", "Futurists", "Gamblers", "Heralds", "Historians",
              "Illuminati", "Infiltrators", "Inventors", "Islanders", "Isolationists", "Leaders", "Merfolk", "Merrymakers",
              "Militants", "Mystics", "Nomads", "Recyclers", "Relentless", "Renegades", "Riverfolk", "Spies",
              "Tinkerers", "Treasure Hunters", "Urban Planners", "Utilitarian", "Weefolk", "The Chosen"
          ];

          // Array of Tapestry City Mats - Special (from base game and expansions)
          const specialCityMats = [
              "Savanna", "Polar", "Veil", "Mesa", "Cavern", "Swamp", "Cloud City", "Canyon", "Quagmire", "Archipelago", "City in a Bottle", "Netherworld",
              "Metropolis", "Monument", "Oasis"
          ];

          // Array of Tapestry City Mats - Original (for Automa solo play)
          const originalCityMats = [
              "Mountains", "Wetland", "Tropical", "Desert", "Grassland", "Forest"
          ];

          // Combine all city mats for score tracking (ensure all possible mats are in the scores object)
          const allCityMats = [...specialCityMats, ...originalCityMats];


          // State variables
          let unusedCivs = []; // Shuffled list of available civs for random generation
          let unusedSpecialMats = []; // Shuffled list of available special mats for random generation
          let unusedOriginalMats = []; // Shuffled list of available original mats for random generation
          let matchHistory = []; // Stores completed matches
          let scores = {}; // Tracks scores for civs and mats
          let currentMatch = null; // Stores the match currently being displayed/scored
          let highestCivScore = 0; // Track the highest total score achieved by any civ
          let currentGameMode = 'pvp'; // Default game mode

          // Fireworks variables
          const canvas = document.getElementById('fireworksCanvas');
          const ctx = canvas.getContext('2d');
          let particles = [];
          let animationFrameId = null;
          let fireworksDuration = 5000; // Duration in milliseconds (e.g., 5 seconds)
          let fireworksTimer = null;

          // Local Storage Keys
          const STORAGE_KEYS = {
              SCORES: 'tapestryTrackerScores',
              MATCH_HISTORY: 'tapestryTrackerMatchHistory',
              HIGHEST_SCORE: 'tapestryTrackerHighestScore',
              GAME_MODE: 'tapestryTrackerGameMode' // Store game mode
          };

          // Get message elements
          const messageBox = document.getElementById('messageBox');
          const generateMessage = document.getElementById('generateMessage'); // This element is not used for messages, can be removed or repurposed

          // Get custom modal elements
          const customConfirmModal = document.getElementById('customConfirmModal');
          const customConfirmMessage = document.getElementById('customConfirmMessage');
          const customConfirmOK = document.getElementById('customConfirmOK');
          const customConfirmCancel = document.getElementById('customConfirmCancel');
          const customModalClose = document.getElementById('customModalClose'); // Get the new close button


          // Variable to store the callback function for the custom confirmation
          let customConfirmCallback = null;

          // Get manual select elements
          const civSelectA = document.getElementById('civSelectA');
          const matSelectA = document.getElementById('matSelectA');
          const civSelectB = document.getElementById('civSelectB');
          const matSelectB = document.getElementById('matSelectB');

          // Get score input elements
          const scoreAInput = document.getElementById('scoreA');
          const scoreBInput = document.getElementById('scoreB');
          let teamALabel = null; // Initialize as null, get in DOMContentLoaded
          let teamBLabel = null; // Initialize as null, get in DOMContentLoaded


          // Get game mode select element
          const gameModeSelect = document.getElementById('gameModeSelect');


          // --- Initialization ---

          // Initialize scores object with all civs and mats
          function initializeScores() {
              scores = {}; // Clear existing scores
              civs.forEach(civ => scores[civ] = { games: 0, points: 0, totalScore: 0 });
              allCityMats.forEach(mat => scores[mat] = { games: 0, points: 0, totalScore: 0 }); // Use allCityMats here
              highestCivScore = 0; // Reset highest score on full reset
          }

          // Shuffle the initial pools for random generation
          function resetPools() {
              unusedCivs = shuffle([...civs]);
              unusedSpecialMats = shuffle([...specialCityMats]);
              unusedOriginalMats = shuffle([...originalCityMats]);
          }

          // Load data from Local Storage
          function loadData() {
              const savedScores = localStorage.getItem(STORAGE_KEYS.SCORES);
              const savedMatchHistory = localStorage.getItem(STORAGE_KEYS.MATCH_HISTORY);
              const savedHighestScore = localStorage.getItem(STORAGE_KEYS.HIGHEST_SCORE);
              const savedGameMode = localStorage.getItem(STORAGE_KEYS.GAME_MODE);


              if (savedScores) {
                  scores = JSON.parse(savedScores);
                  // Ensure all current civs/mats are in scores, even if they weren't saved
                  civs.forEach(civ => {
                      if (!scores[civ]) scores[civ] = { games: 0, points: 0, totalScore: 0 };
                  });
                   allCityMats.forEach(mat => { // Use allCityMats here
                      if (!scores[mat]) scores[mat] = { games: 0, points: 0, totalScore: 0 };
                  });
              } else {
                  initializeScores(); // Initialize if no saved scores
              }

              if (savedMatchHistory) {
                  matchHistory = JSON.parse(savedMatchHistory);
                  // Re-populate unused civs/mats based on history that were originally randomly generated (don't have tieBreakerWinner)
                  // This is a simplification; a more robust solution would track match type and mats used
                  const usedCivsInRandom = new Set();
                  // We can't reliably reconstruct which mat pool was used for random matches from history alone
                  // A full reset of pools on load is simpler and safer for random generation.
                  resetPools();

                  // However, we need to make sure civs used in history are marked as used if we were to implement more complex pool tracking.
                  // For now, we'll just reset the pools.
              } else {
                  matchHistory = [];
                  resetPools(); // Reset pools if no history
              }

              if (savedHighestScore) {
                  highestCivScore = parseInt(savedHighestScore);
              } else {
                  // If no saved highest score, calculate from loaded scores
                  highestCivScore = 0;
                   Object.entries(scores)
                      .filter(([key]) => civs.includes(key))
                      .forEach(([civ, data]) => {
                           if (data.totalScore > highestCivScore) {
                               highestCivScore = data.totalScore;
                           }
                       });
              }

              if (savedGameMode) {
                  currentGameMode = savedGameMode;
                  gameModeSelect.value = currentGameMode; // Set the dropdown value
              } else {
                  currentGameMode = 'pvp'; // Default to pvp if no saved mode
                  gameModeSelect.value = currentGameMode;
              }


              // Ensure currentMatch is null after loading data
              currentMatch = null;

              // Update the current match display to prompt user action
               document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';

              // Update score input labels based on loaded game mode
              updateScoreInputLabels(currentGameMode);

          }

          // Save data to Local Storage
          function saveData() {
              localStorage.setItem(STORAGE_KEYS.SCORES, JSON.stringify(scores));
              localStorage.setItem(STORAGE_KEYS.MATCH_HISTORY, JSON.stringify(matchHistory));
              localStorage.setItem(STORAGE_KEYS.HIGHEST_SCORE, highestCivScore.toString());
              localStorage.setItem(STORAGE_KEYS.GAME_MODE, currentGameMode); // Save game mode
          }


          // --- Utility Functions ---

          // Fisher-Yates (Knuth) Shuffle algorithm
          function shuffle(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [array[i], array[j]] = [array[j], array[i]]; // Swap elements
              }
              return array;
          }

          // Display a general message to the user (this one auto-hides)
          function showMessage(message, type = 'info') {
              messageBox.textContent = message;
              // Remove existing type classes
              messageBox.classList.remove('info', 'error', 'success');
              messageBox.classList.add(type); // Add the new type class

              // Apply styles based on type
              if (type === 'error') {
                  messageBox.style.backgroundColor = '#f8d7da'; // light red
                  messageBox.style.color = '#721c24'; // dark red
                  messageBox.style.borderColor = '#f5c6cb'; // border red
              } else if (type === 'success') {
                   messageBox.style.backgroundColor = '#d4edda'; // light green
                   messageBox.style.color = '#155724'; // dark green
                   messageBox.style.borderColor = '#c3e6cb'; // border green
              } else { // info (default)
                   messageBox.style.backgroundColor = '#fff3cd'; // light yellow
                   messageBox.style.color = '#856404'; // dark yellow
                   messageBox.style.borderColor = '#ffeeba'; // border yellow
              }


              messageBox.style.display = 'block'; // Show the message box

              // This version does NOT auto-hide. It will be closed by clicking it.
          }

           // Show the custom confirmation modal
           function showCustomConfirm(message, callback) {
               customConfirmMessage.textContent = message;
               // Hide the single close button and show the OK/Cancel buttons
               document.querySelector('.custom-modal .button-group').style.display = 'flex';
               customModalClose.style.display = 'none';

               customConfirmModal.style.display = 'flex'; // Show the modal
               customConfirmCallback = callback; // Store the callback function
           }

           // Hide the custom confirmation modal
           function hideCustomConfirm() {
               customConfirmModal.style.display = 'none'; // Hide the modal
               customConfirmCallback = null; // Clear the callback
           }

           // Show a message in the custom modal with a single close button
           function showModalMessage(message) {
               customConfirmMessage.textContent = message;
               // Hide the OK/Cancel buttons and show the single close button
               document.querySelector('.custom-modal .button-group').style.display = 'none';
               customModalClose.style.display = 'block';

               customConfirmModal.style.display = 'flex'; // Show the modal
               customConfirmCallback = null; // No callback needed for a simple message
           }


          // Particle class for fireworks
          class Particle {
              constructor(x, y, color, velocity) {
                  this.x = x;
                  this.y = y;
                  this.color = color;
                  this.velocity = velocity;
                  this.alpha = 1;
                  this.friction = 0.98;
                  this.gravity = 0.5;
                  this.lifeSpan = Math.random() * 50 + 50; // Random lifespan
                  this.creationTime = Date.now();
              }

              draw() {
                  ctx.save();
                  ctx.globalAlpha = this.alpha;
                  ctx.beginPath();
                  ctx.arc(this.x, this.y, 2, 0, Math.PI * 2, false);
                  ctx.fillStyle = this.color;
                  ctx.fill();
                  ctx.restore();
              }

              update() {
                  this.velocity.x *= this.friction;
                  this.velocity.y *= this.friction;
                  this.velocity.y += this.gravity;
                  this.x += this.velocity.x;
                  this.y += this.velocity.y;
                  this.alpha -= 0.01; // Fade out
              }
          }

          // Create fireworks particles
          function createFireworks(x, y, count = 100) {
              const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFFFFF']; // Basic colors
              const color = colors[Math.floor(Math.random() * colors.length)];

              for (let i = 0; i < count; i++) {
                  const angle = Math.random() * Math.PI * 2;
                  const speed = Math.random() * 10 + 2;
                  const velocity = {
                      x: Math.cos(angle) * speed,
                      y: Math.sin(angle) * speed
                  };
                  particles.push(new Particle(x, y, color, velocity));
              }
          }

          // Animation loop for fireworks
          function animateFireworks() {
              animationFrameId = requestAnimationFrame(animateFireworks);
              ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Trail effect
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              particles.forEach((particle, index) => {
                  particle.update();
                  particle.draw();

                  // Remove particles that have faded out or exceeded lifespan
                  if (particle.alpha <= 0 || (Date.now() - particle.creationTime) > particle.lifeSpan * 10) {
                      particles.splice(index, 1);
                  }
              });

              // If no particles left, stop animation and hide canvas/text
              if (particles.length === 0 && !fireworksTimer) {
                  stopFireworks();
              }
          }

          // Start the fireworks display
          function startFireworks(civName, score) {
              canvas.style.display = 'block';
              const highScoreOverlayText = document.getElementById('highScoreOverlayText');
              highScoreOverlayText.textContent = `${civName} achieved a new high score of ${score}!`;
              highScoreOverlayText.style.display = 'block';

              // Set canvas size to match window size
              canvas.width = window.innerWidth;
              canvas.height = window.innerHeight;

              // Create initial fireworks burst in the center
              createFireworks(canvas.width / 2, canvas.height / 2, 200);

              // Create periodic fireworks bursts
              fireworksTimer = setInterval(() => {
                   const x = Math.random() * canvas.width;
                   const y = Math.random() * canvas.height * 0.8; // Avoid bottom edge
                   createFireworks(x, y, 100);
              }, 500); // New burst every 500ms


              // Start animation loop if not already running
              if (!animationFrameId) {
                  animateFireworks();
              }

              // Automatically stop fireworks after a duration
              setTimeout(() => {
                  stopFireworks();
              }, fireworksDuration);
          }

          // Stop the fireworks display
          function stopFireworks() {
              cancelAnimationFrame(animationFrameId);
              clearInterval(fireworksTimer);
              animationFrameId = null;
              fireworksTimer = null;
              particles = []; // Clear particles
              ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
              canvas.style.display = 'none';
              document.getElementById('highScoreOverlayText').style.display = 'none';
          }


          // --- Match and Scoring Logic ---

          // Function to update the score input labels based on game mode
          function updateScoreInputLabels(mode) {
              if (teamALabel && teamBLabel) { // Ensure elements are loaded
                  if (mode === 'automa') {
                      teamALabel.textContent = 'Score for Player:';
                      teamBLabel.textContent = 'Score for Automa:';
                  } else { // pvp mode
                      teamALabel.textContent = 'Score for Team A:';
                      teamBLabel.textContent = 'Score for Team B:';
                  }
              }
          }


          // Function to generate a new random match (the core logic)
          function generateNewRandomMatch() {
               // Reset civ pool if needed
               if (unusedCivs.length < 2) {
                   unusedCivs = shuffle([...civs]);
                   showMessage("Running low on Civs for random generation, reshuffling all available options.");
               }

               let matPoolB = [];
               let unusedMatsB = [];

               // Determine mat pool for Team B based on game mode
               if (currentGameMode === 'automa') {
                   matPoolB = originalCityMats;
                   unusedMatsB = unusedOriginalMats;
                   // Reset original mat pool if needed
                    if (unusedOriginalMats.length < 1) { // Need at least 1 mat for Automa
                        unusedOriginalMats = shuffle([...originalCityMats]);
                        showMessage("Running low on Automa City Mats for random generation, reshuffling all available options.");
                    }
               } else { // pvp mode
                   matPoolB = specialCityMats;
                   unusedMatsB = unusedSpecialMats;
                   // Reset special mat pool if needed
                    if (unusedSpecialMats.length < 2) { // Need at least 2 mats for PvP
                        unusedSpecialMats = shuffle([...specialCityMats]);
                        showMessage("Running low on Special City Mats for random generation, reshuffling all available options.");
                    }
               }

               // Check if we have enough mats after potential reshuffle
               if (currentGameMode === 'automa' && unusedOriginalMats.length < 1) {
                    showMessage("Not enough unique Automa City Mats available to create a new random match.");
                    return null;
               }
                if (currentGameMode === 'pvp' && unusedSpecialMats.length < 2) {
                    showMessage("Not enough unique Special City Mats available to create a new random match.");
                    return null;
               }


               const civ1 = unusedCivs.pop();
               const civ2 = unusedCivs.pop();
               const mat1 = unusedSpecialMats.pop(); // Team A (Player) always uses special mats
               const mat2 = unusedMatsB.pop(); // Team B (Automa or Player) uses the determined pool


               const match = {
                   teamA: { civ: civ1, mat: mat1 },
                   teamB: { civ: civ2, mat: mat2 },
                   scoreA: null,
                   scoreB: null,
                   timestamp: new Date().toISOString(), // Add timestamp
                   mode: currentGameMode // Store the game mode for this match
               };

               currentMatch = match; // Set the current match

               // Update the display with the new match details
               document.getElementById("currentMatch").innerHTML =
                   `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                    <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

               // Update score input labels based on current game mode
               updateScoreInputLabels(currentGameMode);


               // Clear previous scores
               scoreAInput.value = '';
               scoreBInput.value = '';

               showMessage("Random match generated!");

               return match;
          }


          // Handle the click on the Generate Random Match button
          function handleGenerateRandomMatchClick() {
              // Check if a match is already active and show custom confirmation
              if (currentMatch) {
                  showCustomConfirm("A match is already in progress. Are you sure you want to generate a new random match and discard the current one?", (confirmed) => {
                      // This callback runs when the user clicks OK or Cancel
                      if (confirmed) {
                          // User clicked OK
                          currentMatch = null; // Discard current match
                          document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                          updateScoreInputLabels(currentGameMode); // Reset labels
                          scoreAInput.value = '';
                          scoreBInput.value = '';
                          hideTieBreaker(); // Hide tie-breaker if visible
                          generateNewRandomMatch(); // Generate the new match
                          hideCustomConfirm(); // Hide the custom confirm modal after generating
                      }
                      // If not confirmed (user clicked Cancel), do nothing.
                  });
              } else {
                  // If no match is active, just generate a new one
                  generateNewRandomMatch();
              }
          }


          // Create a match from manual selection
          function createManualMatch() {
               // Prevent generating a new match if one is already active
              if (currentMatch) {
                   showCustomConfirm("A match is already in progress. Are you sure you want to create a new manual match and discard the current one?", (confirmed) => {
                       // This callback runs when the user clicks OK or Cancel
                       if (confirmed) {
                           // User clicked OK
                           currentMatch = null; // Discard current match
                            document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                            updateScoreInputLabels(currentGameMode); // Reset labels
                            scoreAInput.value = '';
                            scoreBInput.value = '';
                            hideTieBreaker(); // Hide tie-breaker if visible
                            // Proceed with manual match creation logic
                            const civA = civSelectA.value;
                            const matA = matSelectA.value;
                            const civB = civSelectB.value;
                            const matB = matSelectB.value;

                            // Basic validation (repeat here as this is the "OK" path)
                            if (!civA || !matA || !civB || !matB) {
                                showMessage("Please select a Civ and City Mat for both teams.", 'error');
                                return; // Stop if validation fails
                            }
                             if (civA === civB) {
                                 showMessage("Please select different Civilizations for each team.", 'error');
                                 return; // Stop if validation fails
                            }
                             if (matA === matB) {
                                 showMessage("Please select different City Mats for each team.", 'error');
                                 return; // Stop if validation fails
                            }

                            const match = {
                                teamA: { civ: civA, mat: matA },
                                teamB: { civ: civB, mat: matB },
                                scoreA: null,
                                scoreB: null,
                                timestamp: new Date().toISOString(), // Add timestamp
                                mode: currentGameMode // Store the game mode for this match
                            };

                            currentMatch = match; // Set the current match

                            // Update the display with the new match details
                            document.getElementById("currentMatch").innerHTML =
                                `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                                 <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

                            // Update score input labels based on current game mode
                            updateScoreInputLabels(currentGameMode);


                            // Clear previous scores
                            scoreAInput.value = '';
                            scoreBInput.value = '';

                            showMessage("Manual match created!");
                            hideCustomConfirm(); // Hide the custom confirm modal after creating manual match
                       }
                       // If not confirmed (user clicked Cancel), do nothing.
                   });
              } else {
                  // If no match is active, proceed with manual match creation logic
                  const civA = civSelectA.value;
                  const matA = matSelectA.value;
                  const civB = civSelectB.value;
                  const matB = matSelectB.value;

                  // Basic validation
                  if (!civA || !matA || !civB || !matB) {
                      showMessage("Please select a Civ and City Mat for both teams.", 'error');
                      return;
                  }
                   if (civA === civB) {
                       showMessage("Please select different Civilizations for each team.", 'error');
                       return;
                  }
                   if (matA === matB) {
                       showMessage("Please select different City Mats for each team.", 'error');
                       return;
                  }


                  const match = {
                      teamA: { civ: civA, mat: matA },
                      teamB: { civ: civB, mat: matB },
                      scoreA: null,
                      scoreB: null,
                      timestamp: new Date().toISOString(), // Add timestamp
                      mode: currentGameMode // Store the game mode for this match
                  };

                  currentMatch = match; // Set the current match

                  // Update the display with the new match details
                  document.getElementById("currentMatch").innerHTML =
                      `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                       <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

                  // Update score input labels based on current game mode
                  updateScoreInputLabels(currentGameMode);


                  // Clear previous scores
                  scoreAInput.value = '';
                  scoreBInput.value = '';

                  showMessage("Manual match created!");
              }
          }


          // Submit scores for the current match
          function submitScore() {
              if (!currentMatch) {
                  showMessage("Please generate or create a match first.");
                  return;
              }

              const scoreA = parseInt(scoreAInput.value);
              const scoreB = parseInt(scoreBInput.value);

              // Validate scores
              if (isNaN(scoreA) || isNaN(scoreB)) {
                  showMessage("Please enter valid scores (numbers only).", 'error');
                  return;
              }

              // Store scores in the current match object
              currentMatch.scoreA = scoreA;
              currentMatch.scoreB = scoreB;

              // Check for a tie (only prompt tie-breaker in PvP mode)
              if (scoreA === scoreB && currentGameMode === 'pvp') {
                  promptTieBreaker(); // Prompt for tie-breaker winner
                  return; // Stop here, wait for tie-breaker selection
              }

              // If not a tie or in Automa mode, proceed with score update and history
              updateScores(currentMatch, +1); // Add scores
              matchHistory.push(currentMatch); // Add to history

              // Update the scoreboard tables and check for high score
              updateTables(true); // Pass true to check for high score

              // Update match history display after adding the match
              updateMatchHistoryDisplay();

              // Save data after submitting a score
              saveData();

              // Clear the current match display and inputs after submitting
              currentMatch = null; // Reset current match
              document.getElementById("currentMatch").innerHTML = 'Match submitted. Select or Generate a new match below!';
              updateScoreInputLabels(currentGameMode); // Reset labels
              scoreAInput.value = '';
              scoreBInput.value = '';

              showMessage("Score submitted successfully!");
          }

          // Prompt user to select tie-breaker winner
          function promptTieBreaker() {
              document.getElementById('submitScoreButton').style.display = 'none'; // Hide submit button
              const tieBreakerSection = document.getElementById('tieBreakerSection');
              const tieBreakerButtons = document.getElementById('tieBreakerButtons');

              tieBreakerButtons.innerHTML = `
                  <button onclick="handleTieBreaker('A')">${currentMatch.teamA.civ} (${currentMatch.teamA.mat})</button>
                  <button onclick="handleTieBreaker('B')">${currentMatch.teamB.civ} (${currentMatch.teamB.mat})</button>
              `;
              tieBreakerSection.style.display = 'flex'; // Show tie-breaker section
          }

          // Handle tie-breaker selection
          function handleTieBreaker(winnerTeam) {
              const tieBreakerSection = document.getElementById('tieBreakerSection');
              tieBreakerSection.style.display = 'none'; // Hide tie-breaker section
              document.getElementById('submitScoreButton').style.display = 'block'; // Show submit button

              // Assign points based on tie-breaker winner (3 for winner, 1 for loser)
              if (winnerTeam === 'A') {
                  currentMatch.teamA.points = 3;
                  currentMatch.teamB.points = 1;
                  currentMatch.tieBreakerWinner = 'A'; // Record winner
              } else { // winnerTeam === 'B'
                  currentMatch.teamA.points = 1;
                  currentMatch.teamB.points = 3;
                  currentMatch.tieBreakerWinner = 'B'; // Record winner
              }

              // Update scores using the assigned points
              updateScores(currentMatch, +1);
              matchHistory.push(currentMatch); // Add to history

              // Update the scoreboard tables and check for high score
              updateTables(true); // Pass true to check for high score

              // Update match history display after adding the match
              updateMatchHistoryDisplay();

              // Save data after handling tie-breaker
              saveData();

              // Clear the current match display and inputs after submitting
              currentMatch = null; // Reset current match
              document.getElementById("currentMatch").innerHTML = 'Match submitted. Select or Generate a new match below!';
              updateScoreInputLabels(currentGameMode); // Reset labels
              scoreAInput.value = '';
              scoreBInput.value = '';

              showMessage("Tie-breaker winner recorded and score submitted!");
          }

          // Hide the tie-breaker section
          function hideTieBreaker() {
              document.getElementById('tieBreakerSection').style.display = 'none';
              document.getElementById('submitScoreButton').style.display = 'block';
          }


          // Update scores based on a match result and a delta (for adding or removing)
          function updateScores(match, delta) {
              const { teamA, teamB, scoreA, scoreB, tieBreakerWinner } = match;

              // Points for the match (handle tie-breaker if present)
              let pointsA, pointsB;
              if (tieBreakerWinner) {
                  pointsA = match.teamA.points; // Use assigned points from tie-breaker
                  pointsB = match.teamB.points;
              } else {
                   // Calculate points for non-tie-breaker matches
                   if (scoreA > scoreB) {
                       pointsA = 3;
                       pointsB = 0;
                   } else if (scoreA < scoreB) {
                       pointsA = 0;
                       pointsB = 3;
                   } else {
                       // In Automa mode, a tie means the player (Team A) wins the tie-breaker point
                       if (match.mode === 'automa') {
                           pointsA = 2; // Assuming 2 points for player win in Automa tie, adjust if needed
                           pointsB = 1; // Assuming 1 point for Automa loss in tie, adjust if needed
                       } else { // PvP tie
                           pointsA = 1;
                           pointsB = 1;
                       }
                   }
              }


              // Update games played
              // Ensure the civ/mat exists in the scores object before updating
              if (!scores[teamA.civ]) scores[teamA.civ] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamB.civ]) scores[teamB.civ] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamA.mat]) scores[teamA.mat] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamB.mat]) scores[teamB.mat] = { games: 0, points: 0, totalScore: 0 };


              scores[teamA.civ].games += delta;
              scores[teamB.civ].games += delta;
              scores[teamA.mat].games += delta;
              scores[teamB.mat].games += delta;

              // Update total score
              scores[teamA.civ].totalScore += scoreA * delta; // Multiply by delta
              scores[teamB.civ].totalScore += scoreB * delta; // Multiply by delta
              scores[teamA.mat].totalScore += scoreA * delta; // Multiply by delta
              scores[teamB.mat].totalScore += scoreB * delta; // Multiply by delta


              // Update points
              scores[teamA.civ].points += pointsA * delta;
              scores[teamB.civ].points += pointsB * delta;
              scores[teamA.mat].points += pointsA * delta;
              scores[teamB.mat].points += pointsB * delta;


              // Ensure scores don't go below zero (can happen with undo on initial state)
               for (const key in scores) {
                   scores[key].games = Math.max(0, scores[key].games);
                   scores[key].points = Math.max(0, scores[key].points);
                   // Total score can be negative if undoing a match where points were lost,
                   // but let's ensure it doesn't become nonsensically low.
                   // A more robust solution might track individual score contributions.
                   // For simplicity, we'll allow negative total scores if they occur from undo.
               }
          }

          // Update the scoreboard tables and optionally check for high score
          function updateTables(checkForHighScore = false) {
              // Function to generate table rows and sort
              const generateTableRows = (items, isCivTable) => {
                  // Filter based on whether it's the civ table or mat table
                  const filteredEntries = Object.entries(scores).filter(([key]) => {
                      if (isCivTable) {
                          return civs.includes(key);
                      } else {
                           // For mats, include all mats from both lists
                          return allCityMats.includes(key);
                      }
                  });


                  return filteredEntries.sort((a, b) => {
                          // Sort by points descending
                          if (b[1].points !== a[1].points) {
                              return b[1].points - a[1].points;
                          }
                          // Tie-break by total score descending
                          return b[1].totalScore - a[1].totalScore;
                      }); // Return sorted array, not joined string yet
              };

              // Generate and populate Civ table
              const sortedCivs = generateTableRows(civs, true);
              document.querySelector("#civTable tbody").innerHTML = sortedCivs
                  .map(([civ, data]) =>
                      `<tr>
                          <td>${civ}</td>
                          <td>${data.games}</td>
                          <td>${data.points}</td>
                          <td>${data.totalScore}</td>
                       </tr>`
                  )
                  .join('');

              // Check for new high score if requested
              if (checkForHighScore && sortedCivs.length > 0) {
                  const topCiv = sortedCivs[0];
                  // Only trigger fireworks for a new high score in PvP mode (assuming high score is for player)
                  // If you want high scores for Automa too, adjust this condition
                   if (currentGameMode === 'pvp' && topCiv[1].totalScore > highestCivScore) {
                       highestCivScore = topCiv[1].totalScore;
                       startFireworks(topCiv[0], highestCivScore);
                   } else if (currentGameMode === 'automa' && topCiv[0] === currentMatch.teamA.civ && topCiv[1].totalScore > highestCivScore) {
                       // In Automa mode, only trigger fireworks if the *player's* civ gets a new high score
                       highestCivScore = topCiv[1].totalScore;
                       startFireworks(topCiv[0], highestCivScore);
                   }
              }


              // Generate and populate Mat table (includes all mats)
              const sortedMats = generateTableRows(allCityMats, false);
              document.querySelector("#matTable tbody").innerHTML = sortedMats
                   .map(([mat, data]) =>
                      `<tr>
                          <td>${mat}</td>
                          <td>${data.games}</td>
                          <td>${data.points}</td>
                          <td>${data.totalScore}</td>
                       </tr>`
                  )
                  .join('');
          }

          // Reset the application state
          function resetMatches() {
              // Use custom confirm for reset
              showCustomConfirm("Are you sure you want to reset all match history and scores? This action cannot be undone.", (confirmed) => {
                  // This callback runs when the user clicks OK or Cancel
                  if (confirmed) {
                      // User clicked OK
                      resetPools(); // Reshuffle and reset civ/mat pools
                      matchHistory = []; // Clear match history
                      initializeScores(); // Reset all scores and highestCivScore

                      // Clear the display elements
                      updateMatchHistoryDisplay(); // Clear history display
                      updateTables(); // Clear scoreboards
                      document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                      updateScoreInputLabels(currentGameMode); // Reset labels
                      scoreAInput.value = '';
                      scoreBInput.value = '';
                      currentMatch = null; // Clear current match
                      hideTieBreaker(); // Hide tie-breaker if visible
                      hideCustomConfirm(); // Hide the custom confirm modal

                      // Clear data from Local Storage on reset
                      localStorage.removeItem(STORAGE_KEYS.SCORES);
                      localStorage.removeItem(STORAGE_KEYS.MATCH_HISTORY);
                      localStorage.removeItem(STORAGE_KEYS.HIGHEST_SCORE);
                      // Don't remove game mode on reset, keep the last selected mode


                      showMessage("All data reset.");
                   }
                   // If not confirmed (user clicked Cancel), do nothing.
              });
          }

          // Undo the last submitted match
          function undoLastMatch() {
              const last = matchHistory.pop(); // Remove the last match from history

              if (!last) {
                  showMessage("No matches in history to undo.");
                  return;
              }

              // Revert the scores
              updateScores(last, -1); // Subtract scores

              // Add the civs and mats back to the unused pools if it was a random match
              // Note: Undoing a manual match doesn't add civs/mats back to the *random* pool.
              // This is intentional to keep the random pool behavior consistent.
              // We also need to know which mat pool the undone match used for Team B
              if (last.mode === 'pvp') {
                  unusedCivs.push(last.teamA.civ, last.teamB.civ);
                  unusedSpecialMats.push(last.teamA.mat, last.teamB.mat); // Both used special mats
              } else { // automa mode
                   unusedCivs.push(last.teamA.civ, last.teamB.civ); // Civs are always from the main pool
                   unusedSpecialMats.push(last.teamA.mat); // Player's mat was special
                   unusedOriginalMats.push(last.teamB.mat); // Automa's mat was original
              }


              // Update the scoreboard tables. Recalculate highest score after undo.
              updateTables(true);

              // Update match history display after removing the last match
              updateMatchHistoryDisplay();

              // Save data after undoing a match
              saveData();

              // Optionally, display the undone match details or a message
              document.getElementById("currentMatch").innerHTML = `Undid match: ${last.teamA.civ} (${last.teamA.mat}) ${last.scoreA} - ${last.scoreB} ${last.teamB.civ} (${last.teamB.mat})`;
              updateScoreInputLabels(currentGameMode); // Reset labels to current mode
              scoreAInput.value = '';
              scoreBInput.value = '';
              currentMatch = null; // Ensure currentMatch is clear
              hideTieBreaker(); // Hide tie-breaker if visible


              showMessage("Last match undone.");
          }

          // Helper function to populate a select element
          function populateSelect(selectElement, optionsArray, excludeValue = null) {
              selectElement.innerHTML = '<option value="">-- Select --</option>'; // Add default option

              optionsArray.forEach(option => {
                  if (option !== excludeValue) {
                      const optionElement = document.createElement('option');
                      optionElement.value = option;
                      optionElement.textContent = option;
                      selectElement.appendChild(optionElement);
                  }
              });
          }

          // Function to populate the select dropdowns for manual match creation based on game mode
          function populateManualSelects() {
              // Populate Team A selects with all options (Player always uses special mats)
              populateSelect(civSelectA, civs);
              populateSelect(matSelectA, specialCityMats);

              // Populate Team B selects based on game mode
              if (currentGameMode === 'automa') {
                  // Automa uses original mats
                  populateSelect(civSelectB, civs); // Automa uses any civ
                  populateSelect(matSelectB, originalCityMats); // Automa uses original mats
               } else { // pvp mode
                   // Player B uses special mats
                   populateSelect(civSelectB, civs, civSelectA.value); // Exclude Team A's civ
                   populateSelect(matSelectB, specialCityMats, matSelectA.value); // Exclude Team A's mat
              }
          }

          // Function to update the match history display
          function updateMatchHistoryDisplay() {
               const historyList = document.getElementById("matchHistory");
               historyList.innerHTML = matchHistory.map((match, index) => { // Added index parameter
                   // Format date only with month in letters
                   const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
                   const date = match.timestamp ? `<span class="match-history-date">${new Date(match.timestamp).toLocaleDateString(undefined, dateOptions)}</span>` : ''; // Format date only, month in letters, wrap in span

                   let historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})`;

                   // Mark winner in bold based on score or tie-breaker
                   if (match.tieBreakerWinner === 'A' || (!match.tieBreakerWinner && match.scoreA > match.scoreB)) {
                       historyDetails = `<span class="match-winner">${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA}</span> - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})`;
                   } else if (match.tieBreakerWinner === 'B' || (!match.tieBreakerWinner && match.scoreA < match.scoreB)) {
                        historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - <span class="match-winner">${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})</span>`;
                   } else {
                        // For pure ties (scoreA === scoreB and no tieBreakerWinner recorded)
                        historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat}) (Tie)`;
                   }

                   // Add the match number
                   const matchNumber = `<span class="match-number">${index + 1}.</span>`;

                   // Wrap history details in a span for flexbox
                   historyDetails = `${matchNumber}<span class="match-history-details">${historyDetails}</span>`;

                   // Add game mode to history display
                   const modeText = match.mode === 'automa' ? '(vs Automa)' : '(PvP)';
                   historyDetails += ` ${modeText}`;


                   // Combine details and date, with date on the right
                   return `<li>${historyDetails}${date}</li>`;
               }).join('');
          }


          // Handle game mode change
          function handleGameModeChange() {
              const newMode = gameModeSelect.value;
              if (newMode !== currentGameMode) {
                  // Show confirmation if a match is in progress
                  if (currentMatch) {
                       showCustomConfirm("Changing game mode will discard the current match. Are you sure?", (confirmed) => {
                           if (confirmed) {
                               currentGameMode = newMode;
                               saveData(); // Save the new mode
                               resetMatchDisplay(); // Clear current match display and inputs and update labels
                               populateManualSelects(); // Repopulate selects based on new mode
                               showMessage(`Game mode changed to ${newMode === 'automa' ? 'Player vs Automa' : 'Player vs Player'}.`);
                           } else {
                               // If canceled, revert the select dropdown
                               gameModeSelect.value = currentGameMode;
                           }
                       });
                  } else {
                       // No match in progress, just change mode
                       currentGameMode = newMode;
                       saveData(); // Save the new mode
                       updateScoreInputLabels(currentGameMode); // Update labels immediately
                       populateManualSelects(); // Repopulate selects based on new mode
                       showMessage(`Game mode changed to ${newMode === 'automa' ? 'Player vs Automa' : 'Player vs Player'}.`);
                  }
              }
          }

          // Reset current match display and inputs and update labels
          function resetMatchDisplay() {
              currentMatch = null;
              document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
              updateScoreInputLabels(currentGameMode); // Update labels based on current mode
              scoreAInput.value = '';
              scoreBInput.value = '';
              hideTieBreaker(); // Hide tie-breaker if visible
          }

          // Function to display the "How it Works" explanation in the message box
          /* Removed showHowItWorks function */


          // --- Event Listeners ---

          // Wait for the DOM to be fully loaded before adding event listeners
          document.addEventListener('DOMContentLoaded', () => {
              // Get button elements
              const generateButton = document.getElementById('generateMatchButton');
              const submitButton = document.getElementById('submitScoreButton');
              const resetButton = document.getElementById('resetButton');
              const undoButton = document.getElementById('undoButton');
              const createManualButton = document.getElementById('createManualMatchButton'); // Get manual button
              const howItWorksButton = document.getElementById('howItWorksButton'); // Get the new button
              const fireworksCanvas = document.getElementById('fireworksCanvas'); // Get canvas element
              const scoreButtons = document.querySelectorAll('.score-button'); // Get all score buttons

              // Get score label elements inside DOMContentLoaded
              teamALabel = document.getElementById('teamALabel');
              teamBLabel = document.getElementById('teamBLabel');


              // Add click event listeners
              if (generateButton) generateButton.addEventListener('click', handleGenerateRandomMatchClick); // Use the new handler
              if (submitButton) submitButton.addEventListener('click', submitScore);
              if (resetButton) resetButton.addEventListener('click', resetMatches); // Use the new handler for reset
              if (undoButton) undoButton.addEventListener('click', undoLastMatch);
              if (createManualButton) createManualMatchButton.addEventListener('click', createManualMatch); // Add listener for manual button
              /* Removed howItWorksButton event listener */
              if (customModalClose) customModalClose.addEventListener('click', hideCustomConfirm); // Add listener for the new close button

              // Add click listener to the message box to close it
              if (messageBox) {
                  messageBox.addEventListener('click', () => {
                      messageBox.style.display = 'none'; // Hide the message box on click
                  });
              }


              // Add event listeners for the custom confirmation modal buttons
              customConfirmOK.addEventListener('click', () => {
                  if (customConfirmCallback) {
                      customConfirmCallback(true); // Pass true for OK
                  }
                  hideCustomConfirm(); // Ensure modal is hidden on OK click
              });

              customConfirmCancel.addEventListener('click', () => {
                  if (customConfirmCallback) {
                      customConfirmCallback(false); // Pass false for Cancel
                  }
                  hideCustomConfirm(); // Ensure modal is hidden on Cancel click
              });

              // Add change listeners for manual select elements to exclude selected options from Team B
              civSelectA.addEventListener('change', () => {
                  const selectedCivA = civSelectA.value;
                  populateSelect(civSelectB, civs, selectedCivA);
              });

               matSelectA.addEventListener('change', () => {
                   const selectedMatA = matSelectA.value;
                   // Only exclude Team A's mat in PvP mode
                   if (currentGameMode === 'pvp') {
                       populateSelect(matSelectB, specialCityMats, selectedMatA);
                   } else {
                        // In Automa mode, Team B mat is from a different pool, no exclusion needed based on Team A's mat
                        populateSelect(matSelectB, originalCityMats);
                   }
               });

               // Add click listeners to score buttons
               scoreButtons.forEach(button => {
                   button.addEventListener('click', (event) => {
                       const targetInputId = event.target.dataset.target; // Get the target input id from data-target
                       const value = parseInt(event.target.dataset.value); // Get the value to add/subtract
                       const targetInput = document.getElementById(targetInputId); // Get the target input element
                       const operation = event.target.dataset.operation; // Get the operation ('add' or 'subtract')

                       // Ensure targetInput exists and value is a valid number
                       if (targetInput && !isNaN(value)) {
                           let currentValue = parseInt(targetInput.value) || 0; // Get current value (default to 0 if empty or invalid)

                           if (operation === 'add') {
                               currentValue += value;
                           } else if (operation === 'subtract') {
                               currentValue -= value;
                               // Ensure score doesn't go below zero
                               currentValue = Math.max(0, currentValue);
                           }

                           targetInput.value = currentValue; // Update the input
                            console.log(`Clicked ${operation} ${value} for ${targetInputId}. New value: ${targetInput.value}`); // Log for debugging
                       } else {
                           console.log("Score button click failed: target input or value is invalid."); // Log failure
                       }
                   });
               });


              // Add click listener to stop fireworks when clicking on the canvas
              if (fireworksCanvas) {
                  fireworksCanvas.addEventListener('click', stopFireworks);
              }

              // Add change listener for game mode select
              if (gameModeSelect) {
                  gameModeSelect.addEventListener('change', handleGameModeChange);
              }


              // Load data from local storage on page load
              loadData();
              // Update tables and history display based on loaded data
              updateTables();
              updateMatchHistoryDisplay(); // Update history display on load
              // Populate the manual select dropdowns based on the loaded game mode
              populateManualSelects();


              // Make handleTieBreaker globally accessible for onclick in dynamically created buttons
              window.handleTieBreaker = handleTieBreaker;


              // Resize canvas when window is resized
              window.addEventListener('resize', () => {
                  canvas.width = window.innerWidth;
                  canvas.height = window.innerHeight;
                  // Redraw or adjust particles if needed, but clearing is simpler here
              });
          });

      </script>

  </body>
  </html>

