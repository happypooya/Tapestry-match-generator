  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Tapestry Matchup Tracker</title>
      <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&family=Fira+Sans&family=Inter&display=swap" rel="stylesheet">
      <style>
          /* Basic body styling with background image */
          body {
              /* Replace with your desired background image URL */
              background-image: url('https://cf.geekdo-images.com/7kqDmkUMGxXHr1wNPA7Gvg__original/img/e6rS0PyrVlPpJjCsWPmCaGg9PXc=/0x0/filters:format(jpeg)/pic4884996.jpg');
              background-size: cover; /* Cover the entire viewport */
              background-position: center; /* Center the image */
              background-repeat: no-repeat; /* Do not repeat the image */
              background-attachment: fixed; /* Keep image fixed when scrolling */
              padding: 2em;
              color: #2d3436;
              font-family: 'Inter', sans-serif;
              margin: 0; /* Reset default body margin */
              padding-top: 120px; /* Space for the game cover image */
              position: relative; /* Needed for z-index on game cover */
          }

          /* Semi-transparent overlay for readability */
          body::before {
              content: '';
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background-color: rgba(248, 249, 250, 0.8); /* Light semi-transparent overlay */
              z-index: -2; /* Below content, above background image */
          }


          /* Game cover image positioning */
          .game-cover {
              position: absolute;
              top: 10px;
              left: 10px;
              height: 100px; /* Fixed height */
              width: auto; /* Maintain aspect ratio */
              margin: 0;
              z-index: 2; /* Ensure it's above the panel */
              border: 3px solid #fff; /* Add a white border */
              box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Add shadow */
          }

          #gameCover {
              height: 100%;
              width: auto;
              max-width: 150px; /* Max width for the image */
              border-radius: 8px; /* Slightly smaller border-radius */
              display: block; /* Remove extra space below image */
          }

          /* Main content panel */
          .panel {
              background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white */
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Stronger shadow */
              padding: 1.5em;
              margin: 0 auto; /* Center the panel */
              max-width: 900px;
              position: relative; /* Ensure panel content is above game cover */
              z-index: 1;
              display: flex; /* Use flexbox for overall layout */
              flex-direction: column; /* Stack children vertically */
              gap: 1.5em; /* Add space between sections */
          }

          /* Headings */
          h1, h2 {
              font-family: 'Playfair Display', serif;
              color: #34495e; /* Darker blue-grey */
              text-align: center; /* Center headings */
              margin-bottom: 0.5em; /* Space below headings */
          }

          h1 {
              margin-top: 0; /* Remove top margin for the main title */
              color: #2c3e50; /* Even darker for main title */
          }

          h3 {
              font-family: 'Playfair Display', serif;
              color: #34495e;
              margin-top: 1em;
              margin-bottom: 0.5em;
              text-align: center;
          }


          /* Section styling */
          .section {
              background-color: rgba(248, 249, 250, 0.7); /* More transparent light background */
              border-radius: 6px;
              padding: 1em;
              border: 1px solid #e9ecef; /* Subtle border */
              box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); /* Inner shadow */
          }


          /* Current match display */
          .match-panel {
              margin: 0.5em 0; /* Adjusted margin */
              font-size: 1.4em; /* Slightly larger font */
              text-align: center; /* Center the match text */
              padding: 0.6em; /* Add padding */
              background-color: rgba(233, 236, 239, 0.8); /* More transparent light background */
              border-radius: 4px;
              font-weight: bold;
          }

          .civ {
              font-family: 'Playfair Display', serif;
              font-weight: bold;
              color: #2c3e50; /* Darker blue-grey */
          }

          .mat {
              font-family: 'Fira Sans', sans-serif;
              font-style: italic;
              color: #1abc9c; /* Teal color */
          }

          /* Score input area */
          .score-inputs {
              display: flex;
              flex-direction: column;
              gap: 0.8em; /* Increased gap */
              margin-bottom: 1em;
              align-items: center; /* Center inputs */
          }

          .score-inputs > div { /* Target the direct children divs */
              display: flex;
              align-items: center;
              gap: 0.8em; /* Increased gap between input+buttons groups */
              flex-wrap: wrap; /* Allow items to wrap */
              justify-content: center; /* Center items horizontally */
          }

          input[type="number"] {
              width: 90px; /* Adjusted width */
              padding: 0.6em; /* Adjusted padding */
              border: 1px solid #ced4da; /* Subtle border */
              border-radius: 4px;
              font-size: 1em;
              background-color: #ffffff; /* White background for input */
              text-align: center; /* Center text in number input */
          }

           /* Container for vertical score buttons */
           .score-button-group {
               display: flex;
               flex-direction: column; /* Stack buttons vertically */
               margin-left: 0.4em; /* Space to the left of the button group */
           }

           /* Score button styling */
           .score-button {
               padding: 0.2em 0.8em; /* Smaller padding for score buttons */
               border: none;
               color: white;
               cursor: pointer;
               font-size: 0.9em; /* Smaller font size */
               transition: background-color 0.3s ease, transform 0.1s ease;
               box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Smaller shadow */
               text-align: center; /* Center text in button */
               min-width: 45px; /* Increased min-width for text */
           }

           .score-button.add {
               background-color: #2ecc71; /* Green for add */
               border-top-left-radius: 4px; /* Rounded top corners */
               border-top-right-radius: 4px;
               border-bottom: 1px solid rgba(0,0,0,0.1); /* Small border between + and - */
           }

           .score-button.subtract {
               background-color: #e74c3c; /* Red for subtract */
               border-bottom-left-radius: 4px; /* Rounded bottom corners */
               border-bottom-right-radius: 4px;
           }


           .score-button:hover {
               opacity: 0.9; /* Slight opacity change on hover */
           }

           .score-button:active {
               transform: scale(0.95); /* Slightly shrink when pressed */
               box-shadow: 0 0px 2px rgba(0,0,0,0.1);
           }


          /* Buttons */
          .button-group {
              display: flex;
              justify-content: center; /* Center buttons */
              gap: 1em;
              margin-top: 1em; /* Space above button group */
              flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
          }

          button {
              padding: 0.7em 1.2em; /* Adjusted padding */
              border: none;
              color: white;
              cursor: pointer;
              border-radius: 4px;
              font-size: 1em;
              transition: background-color 0.3s ease, transform 0.1s ease; /* Smooth hover and active effect */
              box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Button shadow */
          }

          button:hover {
              opacity: 0.9; /* Slight opacity change on hover */
          }

          button:active {
              transform: scale(0.98); /* Slightly shrink when pressed */
              box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Smaller shadow when pressed */
          }

           /* Specific button styling for better grouping */
           #generateMatchButton {
               background-color: #2ecc71; /* Emerald green */
           }
           #generateMatchButton:hover {
               background-color: #27ae60;
           }

           #submitScoreButton {
               background-color: #3498db; /* Peter River blue */
           }
            #submitScoreButton:hover {
               background-color: #2980b9;
           }

           #undoButton {
               background-color: #f1c40f; /* Sunflower yellow */
               color: #2d3436; /* Dark text for visibility */
           }
            #undoButton:hover {
               background-color: #f39c12;
           }

           #resetButton {
               background-color: #dc3545; /* Alizarin red */
           }
            #resetButton:hover {
               background-color: #c0392b;
           }

            #createManualMatchButton {
                background-color: #9b59b6; /* Amethyst purple */
            }
             #createManualMatchButton:hover {
                background-color: #8e44ad;
            }


           /* Manual Select Inputs */
           .manual-selects {
               display: flex;
               flex-direction: column;
               gap: 0.8em;
               margin-bottom: 1em;
               align-items: center;
           }

           .manual-selects div {
               display: flex;
               align-items: center;
               gap: 0.5em;
               flex-wrap: wrap; /* Allow items to wrap */
               justify-content: center;
           }

           .manual-selects label {
               font-weight: bold;
               margin-right: 0.5em;
           }

           .manual-selects select {
               padding: 0.5em;
               border: 1px solid #ced4da;
               border-radius: 4px;
               font-size: 1em;
               background-color: #ffffff;
           }

           /* Specific message area for random generate button */
           #generateMessage {
               text-align: center;
               margin-top: 0.5em;
               font-style: italic;
               color: #555;
           }

           /* Tie-breaker section */
           .tie-breaker-section {
               display: none; /* Hidden by default */
               flex-direction: column;
               align-items: center;
               gap: 1em;
               margin-top: 1.5em;
               padding: 1em;
               background-color: rgba(255, 236, 179, 0.8); /* Light orange background */
               border: 1px solid rgba(253, 203, 110, 0.8);
               border-radius: 6px;
           }

           .tie-breaker-section h3 {
               margin: 0;
               color: #e67e22; /* Dark orange */
           }

           .tie-breaker-buttons {
               display: flex;
               gap: 1em;
               flex-wrap: wrap;
               justify-content: center;
           }

           .tie-breaker-buttons button {
               background-color: #f39c12; /* Orange */
           }
            .tie-breaker-buttons button:hover {
                background-color: #e67e22;
            }


          /* Scoreboard tables */
          .scoreboard-table {
              border-collapse: collapse;
              width: 100%;
              margin-top: 1em; /* Adjusted margin */
              box-shadow: 0 1px 4px rgba(0,0,0,0.08); /* Added subtle shadow */
          }

          .scoreboard-table th, .scoreboard-table td {
              border: 1px solid #dee2e6; /* Lighter border */
              padding: 0.8em; /* Adjusted padding */
              text-align: center;
          }

          .scoreboard-table th {
              background-color: #e9ecef; /* Header background */
              font-weight: bold;
              color: #495057;
          }

          .scoreboard-table tbody tr:nth-child(odd) {
              background-color: rgba(248, 249, 250, 0.6); /* Zebra striping with transparency */
          }

          .scoreboard-table tbody tr:hover {
              background-color: rgba(226, 230, 234, 0.7); /* Hover effect with transparency */
          }

          /* Podium styling for top 3 */
          .scoreboard-table tbody tr:nth-child(1) td {
              background: gold;
              font-weight: bold;
          }

          .scoreboard-table tbody tr:nth-child(2) td {
              background: silver;
              font-weight: bold;
          }

          .scoreboard-table tbody tr:nth-child(3) td {
              background: #cd7f32; /* Bronze */
              font-weight: bold;
          }

          /* Match History List */
          #matchHistory {
              list-style: none; /* Remove default list bullets/numbers */
              padding: 0;
              margin-top: 1em;
              max-height: 200px; /* Limit height and add scroll */
              overflow-y: auto;
              border: 1px solid #ced4da; /* Subtle border */
              border-radius: 4px;
              background-color: rgba(255, 255, 255, 0.7); /* White background with transparency */
              box-shadow: 0 2px 6px rgba(0,0,0,0.08); /* Add a subtle shadow to the list */
          }

          #matchHistory li {
              padding: 0.8em 1.2em; /* Increased padding */
              border-bottom: 1px solid #e9ecef; /* Lighter border */
              font-size: 0.95em;
              display: flex; /* Use flexbox for layout within list item */
              justify-content: space-between; /* Space out number/details and date */
              align-items: center; /* Vertically align items */
              background-color: rgba(255, 255, 255, 0.9); /* Slightly more opaque background */
              transition: background-color 0.2s ease; /* Smooth hover transition */
          }

           #matchHistory li:nth-child(odd) {
               background-color: rgba(248, 249, 250, 0.8); /* Subtle zebra striping */
           }

          #matchHistory li:last-child {
              border-bottom: none;
          }

           #matchHistory li:hover {
               background-color: rgba(226, 230, 234, 0.9); /* Highlight on hover */
           }

          .match-winner {
              font-weight: bold;
              color: #2c3e50; /* Darker color for winner */
          }

           .match-history-date {
               font-size: 1em; /* Increased font size */
               color: #555; /* Slightly darker color for better visibility */
               margin-left: 1em; /* Space between match details and date */
               flex-shrink: 0; /* Prevent date from shrinking */
               font-weight: bold; /* Make date bold */
           }

           .match-history-details {
               flex-grow: 1; /* Allow match details to take available space */
               text-align: left; /* Align match details to the left */
               margin-right: 1em; /* Space between details and date */
           }

           .match-number {
               font-weight: bold;
               margin-right: 0.8em; /* Space after the number */
               color: #34495e; /* Darker color for the number */
           }


          /* Message Box */
          #messageBox {
              margin-top: 1em;
              padding: 0.8em;
              background-color: #fff3cd; /* Light yellow */
              border: 1px solid #ffecb5; /* Darker yellow border */
              color: #333;
              border-radius: 4px;
              text-align: center;
              display: none; /* Hidden by default */
              font-weight: bold;
          }

          /* Fireworks Canvas */
          #fireworksCanvas {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: 5; /* Above general content, below modal text */
              pointer-events: none; /* Allow clicks to pass through to elements below */
              display: none; /* Hidden by default */
          }

          /* High Score Text Overlay */
          #highScoreOverlayText {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              z-index: 6; /* Above canvas */
              color: white; /* White text for contrast */
              font-family: 'Playfair Display', serif;
              font-size: 3em; /* Large font size */
              text-shadow: 2px 2px 8px rgba(0,0,0,0.8); /* Text shadow for readability */
              text-align: center;
              pointer-events: none; /* Allow clicks to pass through */
              display: none; /* Hidden by default */
          }

          /* Custom Confirmation Modal */
          .custom-modal-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black overlay */
              display: flex;
              justify-content: center;
              align-items: center;
              z-index: 10; /* Above other content */
              display: none; /* Hidden by default */
          }

          .custom-modal {
              background-color: #fff;
              padding: 2em;
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.2);
              text-align: center;
              max-width: 400px;
              width: 90%; /* Responsive width */
          }

          .custom-modal p {
              margin-bottom: 1.5em;
              font-size: 1.1em;
              color: #333;
          }

          .custom-modal .button-group {
              margin-top: 0; /* Remove top margin as it's in the modal */
          }

          .custom-modal button {
              padding: 0.8em 1.5em;
          }

           .custom-modal .confirm-button {
               background-color: #3498db; /* Blue */
           }
            .custom-modal .confirm-button:hover {
               background-color: #2980b9;
           }

           .custom-modal .cancel-button {
               background-color: #e74c3c; /* Red */
           }
            .custom-modal .cancel-button:hover {
               background-color: #c0392b;
           }


          /* Responsive adjustments */
          @media (max-width: 768px) { /* Adjusted breakpoint for better tablet view */
               body {
                   padding: 1em;
                   padding-top: 110px; /* Adjust for smaller game cover */
               }

               .panel {
                   padding: 1em;
                   gap: 1em;
               }

               .score-inputs > div { /* Target the direct children divs */
                   flex-direction: column; /* Stack score inputs vertically */
                   gap: 0.5em;
               }

               .button-group {
                   flex-direction: column;
                   gap: 0.8em;
               }

               button {
                   width: 100%; /* Full width buttons on smaller screens */
                   padding: 0.8em;
               }

               .game-cover {
                   height: 80px; /* Smaller game cover */
               }

               #gameCover {
                   max-width: 100px;
               }

               body {
                   padding-top: 100px; /* Adjust padding-top */
               }

               .scoreboard-table th, .scoreboard-table td {
                   padding: 0.6em; /* Smaller padding in tables */
                   font-size: 0.9em;
               }

               #highScoreOverlayText {
                   font-size: 2em; /* Smaller font on tablets */
               }

               .manual-selects div {
                   flex-direction: column; /* Stack selects vertically */
                   gap: 0.5em;
               }

               #matchHistory li {
                   flex-direction: column; /* Stack date and details vertically */
                   align-items: flex-start; /* Align items to the start */
               }

               .match-history-date {
                   margin-bottom: 0.5em; /* Space below date */
                   margin-right: 0; /* Remove right margin */
                   margin-left: 0; /* Remove left margin */
               }

                .match-history-details {
                    margin-right: 0; /* Remove right margin */
                }
          }

           @media (max-width: 480px) { /* Even smaller screens */
               body {
                   padding: 0.5em;
                   padding-top: 90px;
               }

               .panel {
                   padding: 0.8em;
               }

               .game-cover {
                   height: 70px;
               }

               #gameCover {
                   max-width: 80px;
               }

                h1 { font-size: 1.5em; }
                h2 { font-size: 1.2em; }

                .match-panel { font-size: 1.2em; }

                #highScoreOverlayText {
                   font-size: 1.5em; /* Even smaller font on phones */
               }
           }

      </style>
  </head>
  <body>

      <div class="game-cover">
          <img id="gameCover" src="https://cf.geekdo-images.com/7kqDmkUMGxXHr1wNPA7Gvg__original/img/e6rS0PyrVlPpJjCsWPmCaGg9PXc=/0x0/filters:format(jpeg)/pic4884996.jpg" alt="Tapestry Board Game Cover">
      </div>

      <div class="panel">
          <h1>Tapestry Matchup Tracker</h1>

          <div class="section">
              <h2>Current Match</h2>
              <div id="currentMatch" class="match-panel">
                  Select or Generate a match below!
              </div>
          </div>

          <div class="section">
              <h2>Generate Random Match</h2>
              <div class="button-group">
                  <button id="generateMatchButton">Generate Random Match</button>
              </div>
              <div id="generateMessage"></div> </div>

           <div class="section">
               <h2>Create Manual Match</h2>
               <div class="manual-selects">
                   <div>
                       <label for="civSelectA">Team A Civ:</label>
                       <select id="civSelectA"></select>
                       <label for="matSelectA">City Mat:</label>
                       <select id="matSelectA"></select>
                   </div>
                   <div>
                       <label for="civSelectB">Team B Civ:</label>
                       <select id="civSelectB"></select>
                       <label for="matSelectB">City Mat:</label>
                       <select id="matSelectB"></select>
                   </div>
               </div>
               <div class="button-group">
                   <button id="createManualMatchButton">Create Manual Match</button>
               </div>
           </div>


          <div class="section">
              <h2>Enter Scores</h2>
              <div class="score-inputs">
                  <div>
                      <label id="teamALabel" for="scoreA">Score for Team A:</label>
                      <input type="number" id="scoreA" min="0">
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="100" data-operation="add">+100</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="100" data-operation="subtract">-100</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="50" data-operation="add">+50</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="50" data-operation="subtract">-50</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="10" data-operation="add">+10</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="10" data-operation="subtract">-10</button>
                      </div>
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreA" data-value="1" data-operation="add">+1</button>
                          <button class="score-button subtract" data-target="scoreA" data-value="1" data-operation="subtract">-1</button>
                      </div>
                  </div>
                  <div>
                      <label id="teamBLabel" for="scoreB">Score for Team B:</label>
                      <input type="number" id="scoreB" min="0">
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="100" data-operation="add">+100</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="100" data-operation="subtract">-100</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="50" data-operation="add">+50</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="50" data-operation="subtract">-50</button>
                      </div>
                      <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="10" data-operation="add">+10</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="10" data-operation="subtract">-10</button>
                      </div>
                       <div class="score-button-group">
                          <button class="score-button add" data-target="scoreB" data-value="1" data-operation="add">+1</button>
                          <button class="score-button subtract" data-target="scoreB" data-value="1" data-operation="subtract">-1</button>
                      </div>
                  </div>
              </div>
              <div class="button-group">
                   <button id="submitScoreButton">Submit Score</button>
              </div>
               <div id="tieBreakerSection" class="tie-breaker-section">
                  <h3>Tie-breaker: Who won?</h3>
                  <div id="tieBreakerButtons" class="tie-breaker-buttons">
                      </div>
              </div>
          </div>

           <div id="messageBox" role="alert"></div>


          <div class="section">
               <h2>History and Options</h2>
               <div class="button-group">
                   <button id="undoButton">Undo Last Match</button>
                   <button id="resetButton">Reset All</button>
               </div>
               <h3>Match History</h3>
               <ol id="matchHistory">
                   </ol>
          </div>


          <div class="section">
              <h2>Civilization Standings</h2>
              <table id="civTable" class="scoreboard-table">
                  <thead>
                      <tr>
                          <th>Civilization</th>
                          <th>Games Played</th>
                          <th>Points</th>
                          <th>Total Score</th>
                      </tr>
                  </thead>
                  <tbody>
                      </tbody>
              </table>
          </div>

          <div class="section">
              <h2>City Mat Standings</h2>
              <table id="matTable" class="scoreboard-table">
                  <thead>
                      <tr>
                          <th>City Mat</th>
                          <th>Games Played</th>
                          <th>Points</th>
                          <th>Total Score</th>
                      </tr>
                  </thead>
                  <tbody>
                      </tbody>
              </table>
          </div>
      </div>

      <canvas id="fireworksCanvas"></canvas>

      <div id="highScoreOverlayText"></div>

      <div id="customConfirmModal" class="custom-modal-overlay">
          <div class="custom-modal">
              <p id="customConfirmMessage"></p>
              <div class="button-group">
                  <button id="customConfirmOK" class="confirm-button">OK</button>
                  <button id="customConfirmCancel" class="cancel-button">Cancel</button>
              </div>
          </div>
      </div>


      <script>
          // Array of Tapestry Civilizations
          const civs = [
              "Adventurers", "Alchemists", "Aliens", "Architects", "Artificiers", "Celestials", "Collectors", "Crafters",
              "Elder Ones", "Entertainers", "Faefolk", "Followers", "Futurists", "Gamblers", "Heralds", "Historians",
              "Illuminati", "Infiltrators", "Inventors", "Islanders", "Isolationists", "Leaders", "Merfolk", "Merrymakers",
              "Militants", "Mystics", "Nomads", "Recyclers", "Relentless", "Renegades", "Riverfolk", "Spies",
              "Tinkerers", "Treasure Hunters", "Urban Planners", "Utilitarian", "Weefolk", "The Chosen"
          ];

          // Array of Tapestry City Mats
          const cityMats = [
              "Savanna", "Polar", "Veil", "Mesa", "Cavern", "Swamp", "Cloud City", "Canyon", "Quagmire", "Archipelago", "City in a Bottle", "Netherworld"
          ];

          // State variables
          let unusedCivs = []; // Shuffled list of available civs for random generation
          let unusedMats = []; // Shuffled list of available mats for random generation
          let matchHistory = []; // Stores completed matches
          let scores = {}; // Tracks scores for civs and mats
          let currentMatch = null; // Stores the match currently being displayed/scored
          let highestCivScore = 0; // Track the highest total score achieved by any civ

          // Fireworks variables
          const canvas = document.getElementById('fireworksCanvas');
          const ctx = canvas.getContext('2d');
          let particles = [];
          let animationFrameId = null;
          let fireworksDuration = 5000; // Duration in milliseconds (e.g., 5 seconds)
          let fireworksTimer = null;

          // Local Storage Keys
          const STORAGE_KEYS = {
              SCORES: 'tapestryTrackerScores',
              MATCH_HISTORY: 'tapestryTrackerMatchHistory',
              HIGHEST_SCORE: 'tapestryTrackerHighestScore'
          };

          // Get message elements
          const messageBox = document.getElementById('messageBox');
          const generateMessage = document.getElementById('generateMessage');

          // Get custom modal elements
          const customConfirmModal = document.getElementById('customConfirmModal');
          const customConfirmMessage = document.getElementById('customConfirmMessage');
          const customConfirmOK = document.getElementById('customConfirmOK');
          const customConfirmCancel = document.getElementById('customConfirmCancel');

          // Variable to store the callback function for the custom confirmation
          let customConfirmCallback = null;

          // Get manual select elements
          const civSelectA = document.getElementById('civSelectA');
          const matSelectA = document.getElementById('matSelectA');
          const civSelectB = document.getElementById('civSelectB');
          const matSelectB = document.getElementById('matSelectB');

          // Get score input elements
          const scoreAInput = document.getElementById('scoreA');
          const scoreBInput = document.getElementById('scoreB');


          // --- Initialization ---

          // Initialize scores object with all civs and mats
          function initializeScores() {
              scores = {}; // Clear existing scores
              civs.forEach(civ => scores[civ] = { games: 0, points: 0, totalScore: 0 });
              cityMats.forEach(mat => scores[mat] = { games: 0, points: 0, totalScore: 0 });
              highestCivScore = 0; // Reset highest score on full reset
          }

          // Shuffle the initial pools for random generation
          function resetPools() {
              unusedCivs = shuffle([...civs]);
              unusedMats = shuffle([...cityMats]);
          }

          // Load data from Local Storage
          function loadData() {
              const savedScores = localStorage.getItem(STORAGE_KEYS.SCORES);
              const savedMatchHistory = localStorage.getItem(STORAGE_KEYS.MATCH_HISTORY);
              const savedHighestScore = localStorage.getItem(STORAGE_KEYS.HIGHEST_SCORE);

              if (savedScores) {
                  scores = JSON.parse(savedScores);
                  // Ensure all current civs/mats are in scores, even if they weren't saved
                  civs.forEach(civ => {
                      if (!scores[civ]) scores[civ] = { games: 0, points: 0, totalScore: 0 };
                  });
                   cityMats.forEach(mat => {
                      if (!scores[mat]) scores[mat] = { games: 0, points: 0, totalScore: 0 };
                  });
              } else {
                  initializeScores(); // Initialize if no saved scores
              }

              if (savedMatchHistory) {
                  matchHistory = JSON.parse(savedMatchHistory);
                  // Re-populate unused civs/mats based on history that were originally randomly generated (don't have tieBreakerWinner)
                  // This is a simplification; a more robust solution would track match type
                  const usedCivsInRandom = new Set();
                  const usedMatsInRandom = new Set();
                  matchHistory.forEach(match => {
                      if (!match.tieBreakerWinner) {
                           usedCivsInRandom.add(match.teamA.civ);
                           usedCivsInRandom.add(match.teamB.civ);
                           usedMatsInRandom.add(match.teamA.mat);
                           usedMatsInRandom.add(match.teamB.mat);
                      }
                  });
                  unusedCivs = civs.filter(civ => !usedCivsInRandom.has(civ));
                  unusedMats = cityMats.filter(mat => !usedMatsInRandom.has(mat));
                  // Shuffle remaining unused pools
                  unusedCivs = shuffle(unusedCivs);
                  unusedMats = shuffle(unusedMats);

              } else {
                  matchHistory = [];
                  resetPools(); // Reset pools if no history
              }

              if (savedHighestScore) {
                  highestCivScore = parseInt(savedHighestScore);
              } else {
                  // If no saved highest score, calculate from loaded scores
                  highestCivScore = 0;
                   Object.entries(scores)
                      .filter(([key]) => civs.includes(key))
                      .forEach(([civ, data]) => {
                           if (data.totalScore > highestCivScore) {
                               highestCivScore = data.totalScore;
                           }
                       });
              }

              // Ensure currentMatch is null after loading data
              currentMatch = null;

              // Update the current match display to prompt user action
               document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';

          }

          // Save data to Local Storage
          function saveData() {
              localStorage.setItem(STORAGE_KEYS.SCORES, JSON.stringify(scores));
              localStorage.setItem(STORAGE_KEYS.MATCH_HISTORY, JSON.stringify(matchHistory));
              localStorage.setItem(STORAGE_KEYS.HIGHEST_SCORE, highestCivScore.toString());
          }


          // --- Utility Functions ---

          // Fisher-Yates (Knuth) Shuffle algorithm
          function shuffle(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [array[i], array[j]] = [array[j], array[i]]; // Swap elements
              }
              return array;
          }

          // Display a general message to the user
          function showMessage(message, type = 'info') {
              messageBox.textContent = message;
              messageBox.style.display = 'block'; // Show the message box

              // Optional: Add different styling based on type (e.g., 'error', 'success')
              /*
              if (type === 'error') {
                  messageBox.style.backgroundColor = '#f8d7da'; // light red
                  messageBox.style.color = '#721c24'; // dark red
                  messageBox.style.borderColor = '#f5c6cb'; // border red
              } else if (type === 'success') {
                   messageBox.style.backgroundColor = '#d4edda'; // light green
                   messageBox.style.color = '#155724'; // dark green
                   messageBox.style.borderColor = '#c3e6cb'; // border green
              } else { // info
                   messageBox.style.backgroundColor = '#fff3cd'; // light yellow
                   messageBox.style.color = '#856404'; // dark yellow
                   messageBox.style.borderColor = '#ffeeba'; // border yellow
              }
              */

              // Hide the message after a few seconds
              setTimeout(() => {
                  messageBox.style.display = 'none';
              }, 5000); // Hide after 5 seconds
          }

           // Show the custom confirmation modal
           function showCustomConfirm(message, callback) {
               customConfirmMessage.textContent = message;
               customConfirmModal.style.display = 'flex'; // Show the modal
               customConfirmCallback = callback; // Store the callback function
           }

           // Hide the custom confirmation modal
           function hideCustomConfirm() {
               customConfirmModal.style.display = 'none'; // Hide the modal
               customConfirmCallback = null; // Clear the callback
           }


          // Particle class for fireworks
          class Particle {
              constructor(x, y, color, velocity) {
                  this.x = x;
                  this.y = y;
                  this.color = color;
                  this.velocity = velocity;
                  this.alpha = 1;
                  this.friction = 0.98;
                  this.gravity = 0.5;
                  this.lifeSpan = Math.random() * 50 + 50; // Random lifespan
                  this.creationTime = Date.now();
              }

              draw() {
                  ctx.save();
                  ctx.globalAlpha = this.alpha;
                  ctx.beginPath();
                  ctx.arc(this.x, this.y, 2, 0, Math.PI * 2, false);
                  ctx.fillStyle = this.color;
                  ctx.fill();
                  ctx.restore();
              }

              update() {
                  this.velocity.x *= this.friction;
                  this.velocity.y *= this.friction;
                  this.velocity.y += this.gravity;
                  this.x += this.velocity.x;
                  this.y += this.velocity.y;
                  this.alpha -= 0.01; // Fade out
              }
          }

          // Create fireworks particles
          function createFireworks(x, y, count = 100) {
              const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFFFFF']; // Basic colors
              const color = colors[Math.floor(Math.random() * colors.length)];

              for (let i = 0; i < count; i++) {
                  const angle = Math.random() * Math.PI * 2;
                  const speed = Math.random() * 10 + 2;
                  const velocity = {
                      x: Math.cos(angle) * speed,
                      y: Math.sin(angle) * speed
                  };
                  particles.push(new Particle(x, y, color, velocity));
              }
          }

          // Animation loop for fireworks
          function animateFireworks() {
              animationFrameId = requestAnimationFrame(animateFireworks);
              ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Trail effect
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              particles.forEach((particle, index) => {
                  particle.update();
                  particle.draw();

                  // Remove particles that have faded out or exceeded lifespan
                  if (particle.alpha <= 0 || (Date.now() - particle.creationTime) > particle.lifeSpan * 10) {
                      particles.splice(index, 1);
                  }
              });

              // If no particles left, stop animation and hide canvas/text
              if (particles.length === 0 && !fireworksTimer) {
                  stopFireworks();
              }
          }

          // Start the fireworks display
          function startFireworks(civName, score) {
              canvas.style.display = 'block';
              const highScoreOverlayText = document.getElementById('highScoreOverlayText');
              highScoreOverlayText.textContent = `${civName} achieved a new high score of ${score}!`;
              highScoreOverlayText.style.display = 'block';

              // Set canvas size to match window size
              canvas.width = window.innerWidth;
              canvas.height = window.innerHeight;

              // Create initial fireworks burst in the center
              createFireworks(canvas.width / 2, canvas.height / 2, 200);

              // Create periodic fireworks bursts
              fireworksTimer = setInterval(() => {
                   const x = Math.random() * canvas.width;
                   const y = Math.random() * canvas.height * 0.8; // Avoid bottom edge
                   createFireworks(x, y, 100);
              }, 500); // New burst every 500ms


              // Start animation loop if not already running
              if (!animationFrameId) {
                  animateFireworks();
              }

              // Automatically stop fireworks after a duration
              setTimeout(() => {
                  stopFireworks();
              }, fireworksDuration);
          }

          // Stop the fireworks display
          function stopFireworks() {
              cancelAnimationFrame(animationFrameId);
              clearInterval(fireworksTimer);
              animationFrameId = null;
              fireworksTimer = null;
              particles = []; // Clear particles
              ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
              canvas.style.display = 'none';
              document.getElementById('highScoreOverlayText').style.display = 'none';
          }


          // --- Match and Scoring Logic ---

          // Function to generate a new random match (the core logic)
          function generateNewRandomMatch() {
               // Re-shuffle if not enough civs or city mats left
               if (unusedCivs.length < 2) {
                   resetPools(); // Reshuffle both if civs run low
                   showGenerateMessage("Running low on Civs for random generation, reshuffling all available options.");
               }
               if (unusedMats.length < 2) {
                    resetPools(); // Reshuffle both if mats run low
                    showGenerateMessage("Running low on City Mats for random generation, reshuffling all available options.");
               }

               // Ensure we still have enough after potential reshuffle
               if (unusedCivs.length < 2 || unusedMats.length < 2) {
                   showGenerateMessage("Not enough unique Civs or Mats available to create a new random match.");
                   return null; // Cannot create a match
               }

               const civ1 = unusedCivs.pop();
               const civ2 = unusedCivs.pop();
               const mat1 = unusedMats.pop();
               const mat2 = unusedMats.pop();

               const match = {
                   teamA: { civ: civ1, mat: mat1 },
                   teamB: { civ: civ2, mat: mat2 },
                   scoreA: null,
                   scoreB: null,
                   timestamp: new Date().toISOString() // Add timestamp
               };

               currentMatch = match; // Set the current match

               // Update the display with the new match details
               document.getElementById("currentMatch").innerHTML =
                   `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                    <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

               // Update score input labels
               document.getElementById("teamALabel").textContent = `Score for ${currentMatch.teamA.civ}:`;
               document.getElementById("teamBLabel").textContent = `Score for ${currentMatch.teamB.civ}:`;

               // Clear previous scores
               scoreAInput.value = '';
               scoreBInput.value = '';

               showGenerateMessage("Random match generated!");

               return match;
          }


          // Handle the click on the Generate Random Match button
          function handleGenerateRandomMatchClick() {
              // Check if a match is already active and show custom confirmation
              if (currentMatch) {
                  showCustomConfirm("A match is already in progress. Are you sure you want to generate a new random match and discard the current one?", (confirmed) => {
                      // This callback runs when the user clicks OK or Cancel
                      if (confirmed) {
                          // User clicked OK
                          currentMatch = null; // Discard current match
                          document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                          document.getElementById("teamALabel").textContent = 'Score for Team A:';
                          document.getElementById("teamBLabel").textContent = 'Score for Team B:';
                          scoreAInput.value = '';
                          scoreBInput.value = '';
                          hideTieBreaker(); // Hide tie-breaker if visible
                          generateNewRandomMatch(); // Generate the new match
                      }
                      // If not confirmed (user clicked Cancel), do nothing.
                  });
              } else {
                  // If no match is active, just generate a new one
                  generateNewRandomMatch();
              }
          }


          // Create a match from manual selection
          function createManualMatch() {
               // Prevent generating a new match if one is already active
              if (currentMatch) {
                   showCustomConfirm("A match is already in progress. Are you sure you want to create a new manual match and discard the current one?", (confirmed) => {
                       // This callback runs when the user clicks OK or Cancel
                       if (confirmed) {
                           // User clicked OK
                           currentMatch = null; // Discard current match
                            document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                            document.getElementById("teamALabel").textContent = 'Score for Team A:';
                            document.getElementById("teamBLabel").textContent = 'Score for Team B:';
                            scoreAInput.value = '';
                            scoreBInput.value = '';
                            hideTieBreaker(); // Hide tie-breaker if visible
                            // Proceed with manual match creation logic
                            const civA = civSelectA.value;
                            const matA = matSelectA.value;
                            const civB = civSelectB.value;
                            const matB = matSelectB.value;

                            // Basic validation (repeat here as this is the "OK" path)
                            if (!civA || !matA || !civB || !matB) {
                                showMessage("Please select a Civ and City Mat for both teams.", 'error');
                                return; // Stop if validation fails
                            }
                             if (civA === civB) {
                                 showMessage("Please select different Civilizations for each team.", 'error');
                                 return; // Stop if validation fails
                            }
                             if (matA === matB) {
                                 showMessage("Please select different City Mats for each team.", 'error');
                                 return; // Stop if validation fails
                            }

                            const match = {
                                teamA: { civ: civA, mat: matA },
                                teamB: { civ: civB, mat: matB },
                                scoreA: null,
                                scoreB: null,
                                timestamp: new Date().toISOString() // Add timestamp
                            };

                            currentMatch = match; // Set the current match

                            // Update the display with the new match details
                            document.getElementById("currentMatch").innerHTML =
                                `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                                 <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

                            // Update score input labels
                            document.getElementById("teamALabel").textContent = `Score for ${currentMatch.teamA.civ}:`;
                            document.getElementById("teamBLabel").textContent = `Score for ${currentMatch.teamB.civ}:`;

                            // Clear previous scores
                            scoreAInput.value = '';
                            scoreBInput.value = '';

                            showMessage("Manual match created!");
                       }
                       // If not confirmed (user clicked Cancel), do nothing.
                   });
              } else {
                  // If no match is active, proceed with manual match creation logic
                  const civA = civSelectA.value;
                  const matA = matSelectA.value;
                  const civB = civSelectB.value;
                  const matB = matSelectB.value;

                  // Basic validation
                  if (!civA || !matA || !civB || !matB) {
                      showMessage("Please select a Civ and City Mat for both teams.", 'error');
                      return;
                  }
                   if (civA === civB) {
                       showMessage("Please select different Civilizations for each team.", 'error');
                       return;
                  }
                   if (matA === matB) {
                       showMessage("Please select different City Mats for each team.", 'error');
                       return;
                  }


                  const match = {
                      teamA: { civ: civA, mat: matA },
                      teamB: { civ: civB, mat: matB },
                      scoreA: null,
                      scoreB: null,
                      timestamp: new Date().toISOString() // Add timestamp
                  };

                  currentMatch = match; // Set the current match

                  // Update the display with the new match details
                  document.getElementById("currentMatch").innerHTML =
                      `<span class="civ">${currentMatch.teamA.civ}</span> (<span class="mat">${currentMatch.teamA.mat}</span>) VS
                       <span class="civ">${currentMatch.teamB.civ}</span> (<span class="mat">${currentMatch.teamB.mat}</span>)`;

                  // Update score input labels
                  document.getElementById("teamALabel").textContent = `Score for ${currentMatch.teamA.civ}:`;
                  document.getElementById("teamBLabel").textContent = `Score for ${currentMatch.teamB.civ}:`;

                  // Clear previous scores
                  scoreAInput.value = '';
                  scoreBInput.value = '';

                  showMessage("Manual match created!");
              }
          }


          // Submit scores for the current match
          function submitScore() {
              if (!currentMatch) {
                  showMessage("Please generate or create a match first.");
                  return;
              }

              const scoreA = parseInt(scoreAInput.value);
              const scoreB = parseInt(scoreBInput.value);

              // Validate scores
              if (isNaN(scoreA) || isNaN(scoreB)) {
                  showMessage("Please enter valid scores (numbers only).", 'error');
                  return;
              }

              // Store scores in the current match object
              currentMatch.scoreA = scoreA;
              currentMatch.scoreB = scoreB;

              // Check for a tie
              if (scoreA === scoreB) {
                  promptTieBreaker(); // Prompt for tie-breaker winner
                  return; // Stop here, wait for tie-breaker selection
              }

              // If not a tie, proceed with score update and history
              updateScores(currentMatch, +1); // Add scores
              matchHistory.push(currentMatch); // Add to history

              // Update the scoreboard tables and check for high score
              updateTables(true); // Pass true to check for high score

              // Update match history display after adding the match
              updateMatchHistoryDisplay();

              // Save data after submitting a score
              saveData();

              // Clear the current match display and inputs after submitting
              currentMatch = null; // Reset current match
              document.getElementById("currentMatch").innerHTML = 'Match submitted. Select or Generate a new match below!';
              document.getElementById("teamALabel").textContent = 'Score for Team A:';
              document.getElementById("teamBLabel").textContent = 'Score for Team B:';
              scoreAInput.value = '';
              scoreBInput.value = '';

              showMessage("Score submitted successfully!");
          }

          // Prompt user to select tie-breaker winner
          function promptTieBreaker() {
              document.getElementById('submitScoreButton').style.display = 'none'; // Hide submit button
              const tieBreakerSection = document.getElementById('tieBreakerSection');
              const tieBreakerButtons = document.getElementById('tieBreakerButtons');

              tieBreakerButtons.innerHTML = `
                  <button onclick="handleTieBreaker('A')">${currentMatch.teamA.civ} (${currentMatch.teamA.mat})</button>
                  <button onclick="handleTieBreaker('B')">${currentMatch.teamB.civ} (${currentMatch.teamB.mat})</button>
              `;
              tieBreakerSection.style.display = 'flex'; // Show tie-breaker section
          }

          // Handle tie-breaker selection
          function handleTieBreaker(winnerTeam) {
              const tieBreakerSection = document.getElementById('tieBreakerSection');
              tieBreakerSection.style.display = 'none'; // Hide tie-breaker section
              document.getElementById('submitScoreButton').style.display = 'block'; // Show submit button

              // Assign points based on tie-breaker winner (3 for winner, 1 for loser)
              if (winnerTeam === 'A') {
                  currentMatch.teamA.points = 3;
                  currentMatch.teamB.points = 1;
                  currentMatch.tieBreakerWinner = 'A'; // Record winner
              } else { // winnerTeam === 'B'
                  currentMatch.teamA.points = 1;
                  currentMatch.teamB.points = 3;
                  currentMatch.tieBreakerWinner = 'B'; // Record winner
              }

              // Update scores using the assigned points
              updateScores(currentMatch, +1);
              matchHistory.push(currentMatch); // Add to history

              // Update the scoreboard tables and check for high score
              updateTables(true); // Pass true to check for high score

              // Update match history display after adding the match
              updateMatchHistoryDisplay();

              // Save data after handling tie-breaker
              saveData();

              // Clear the current match display and inputs after submitting
              currentMatch = null; // Reset current match
              document.getElementById("currentMatch").innerHTML = 'Match submitted. Select or Generate a new match below!';
              document.getElementById("teamALabel").textContent = 'Score for Team A:';
              document.getElementById("teamBLabel").textContent = 'Score for Team B:';
              scoreAInput.value = '';
              scoreBInput.value = '';

              showMessage("Tie-breaker winner recorded and score submitted!");
          }

          // Hide the tie-breaker section
          function hideTieBreaker() {
              document.getElementById('tieBreakerSection').style.display = 'none';
              document.getElementById('submitScoreButton').style.display = 'block';
          }


          // Update scores based on a match result and a delta (for adding or removing)
          function updateScores(match, delta) {
              const { teamA, teamB, scoreA, scoreB, tieBreakerWinner } = match;

              // Points for the match (handle tie-breaker if present)
              let pointsA, pointsB;
              if (tieBreakerWinner) {
                  pointsA = match.teamA.points; // Use assigned points from tie-breaker
                  pointsB = match.teamB.points;
              } else {
                   // Calculate points for non-tie-breaker matches
                   if (scoreA > scoreB) {
                       pointsA = 3;
                       pointsB = 0;
                   } else if (scoreA < scoreB) {
                       pointsA = 0;
                       pointsB = 3;
                   } else {
                       pointsA = 1;
                       pointsB = 1;
                   }
              }


              // Update games played
              // Ensure the civ/mat exists in the scores object before updating
              if (!scores[teamA.civ]) scores[teamA.civ] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamB.civ]) scores[teamB.civ] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamA.mat]) scores[teamA.mat] = { games: 0, points: 0, totalScore: 0 };
              if (!scores[teamB.mat]) scores[teamB.mat] = { games: 0, points: 0, totalScore: 0 };


              scores[teamA.civ].games += delta;
              scores[teamB.civ].games += delta;
              scores[teamA.mat].games += delta;
              scores[teamB.mat].games += delta;

              // Update total score
              scores[teamA.civ].totalScore += scoreA * delta; // Multiply by delta
              scores[teamB.civ].totalScore += scoreB * delta; // Multiply by delta
              scores[teamA.mat].totalScore += scoreA * delta; // Multiply by delta
              scores[teamB.mat].totalScore += scoreB * delta; // Multiply by delta


              // Update points
              scores[teamA.civ].points += pointsA * delta;
              scores[teamB.civ].points += pointsB * delta;
              scores[teamA.mat].points += pointsA * delta;
              scores[teamB.mat].points += pointsB * delta;


              // Ensure scores don't go below zero (can happen with undo on initial state)
               for (const key in scores) {
                   scores[key].games = Math.max(0, scores[key].games);
                   scores[key].points = Math.max(0, scores[key].points);
                   // Total score can be negative if undoing a match where points were lost,
                   // but let's ensure it doesn't become nonsensically low.
                   // A more robust solution might track individual score contributions.
                   // For simplicity, we'll allow negative total scores if they occur from undo.
               }
          }

          // Update the scoreboard tables and optionally check for high score
          function updateTables(checkForHighScore = false) {
              // Function to generate table rows and sort
              const generateTableRows = (items, isCivTable) => {
                  return Object.entries(scores)
                      .filter(([key]) => isCivTable ? civs.includes(key) : cityMats.includes(key))
                      .sort((a, b) => {
                          // Sort by points descending
                          if (b[1].points !== a[1].points) {
                              return b[1].points - a[1].points;
                          }
                          // Tie-break by total score descending
                          return b[1].totalScore - a[1].totalScore;
                      }); // Return sorted array, not joined string yet
              };

              // Generate and populate Civ table
              const sortedCivs = generateTableRows(civs, true);
              document.querySelector("#civTable tbody").innerHTML = sortedCivs
                  .map(([civ, data]) =>
                      `<tr>
                          <td>${civ}</td>
                          <td>${data.games}</td>
                          <td>${data.points}</td>
                          <td>${data.totalScore}</td>
                       </tr>`
                  )
                  .join('');

              // Check for new high score if requested
              if (checkForHighScore && sortedCivs.length > 0) {
                  const topCiv = sortedCivs[0];
                  if (topCiv[1].totalScore > highestCivScore) {
                      highestCivScore = topCiv[1].totalScore;
                      // Trigger fireworks instead of showing modal
                      startFireworks(topCiv[0], highestCivScore);
                  }
              }


              // Generate and populate Mat table
              const sortedMats = generateTableRows(cityMats, false);
              document.querySelector("#matTable tbody").innerHTML = sortedMats
                   .map(([mat, data]) =>
                      `<tr>
                          <td>${mat}</td>
                          <td>${data.games}</td>
                          <td>${data.points}</td>
                          <td>${data.totalScore}</td>
                       </tr>`
                  )
                  .join('');
          }

          // Reset the application state
          function resetMatches() {
              // Use custom confirm for reset
              showCustomConfirm("Are you sure you want to reset all match history and scores? This action cannot be undone.", (confirmed) => {
                  // This callback runs when the user clicks OK or Cancel
                  if (confirmed) {
                      // User clicked OK
                      resetPools(); // Reshuffle and reset civ/mat pools
                      matchHistory = []; // Clear match history
                      initializeScores(); // Reset all scores and highestCivScore

                      // Clear the display elements
                      updateMatchHistoryDisplay(); // Clear history display
                      updateTables(); // Clear scoreboards
                      document.getElementById("currentMatch").innerHTML = 'Select or Generate a match below!';
                      document.getElementById("teamALabel").textContent = 'Score for Team A:';
                      document.getElementById("teamBLabel").textContent = 'Score for Team B:';
                      scoreAInput.value = '';
                      scoreBInput.value = '';
                      currentMatch = null; // Clear current match
                      hideTieBreaker(); // Hide tie-breaker if visible
                      hideCustomConfirm(); // Hide the custom confirm modal

                      // Clear data from Local Storage on reset
                      localStorage.removeItem(STORAGE_KEYS.SCORES);
                      localStorage.removeItem(STORAGE_KEYS.MATCH_HISTORY);
                      localStorage.removeItem(STORAGE_KEYS.HIGHEST_SCORE);


                      showMessage("All data reset.");
                   }
                   // If not confirmed (user clicked Cancel), do nothing.
              });
          }

          // Undo the last submitted match
          function undoLastMatch() {
              const last = matchHistory.pop(); // Remove the last match from history

              if (!last) {
                  showMessage("No matches in history to undo.");
                  return;
              }

              // Revert the scores
              updateScores(last, -1); // Subtract scores

              // Add the civs and mats back to the unused pools if it was a random match
              // Note: Undoing a manual match doesn't add civs/mats back to the *random* pool.
              // This is intentional to keep the random pool behavior consistent.
              if (!last.tieBreakerWinner) { // Assuming only random matches wouldn't have this initially
                  unusedCivs.push(last.teamA.civ, last.teamB.civ);
                  unusedMats.push(last.teamA.mat, last.teamB.mat);
              }

              // Update the scoreboard tables. Recalculate highest score after undo.
              updateTables(true);

              // Update match history display after removing the last match
              updateMatchHistoryDisplay();

              // Save data after undoing a match
              saveData();

              // Optionally, display the undone match details or a message
              document.getElementById("currentMatch").innerHTML = `Undid match: ${last.teamA.civ} (${last.teamA.mat}) ${last.scoreA} - ${last.scoreB} ${last.teamB.civ} (${last.teamB.mat})`;
              document.getElementById("teamALabel").textContent = 'Score for Team A:';
              document.getElementById("teamBLabel").textContent = 'Score for Team B:';
              scoreAInput.value = '';
              scoreBInput.value = '';
              currentMatch = null; // Ensure currentMatch is clear
              hideTieBreaker(); // Hide tie-breaker if visible


              showMessage("Last match undone.");
          }

          // Helper function to populate a select element
          function populateSelect(selectElement, optionsArray, excludeValue = null) {
              selectElement.innerHTML = '<option value="">-- Select --</option>'; // Add default option

              optionsArray.forEach(option => {
                  if (option !== excludeValue) {
                      const optionElement = document.createElement('option');
                      optionElement.value = option;
                      optionElement.textContent = option;
                      selectElement.appendChild(optionElement);
                  }
              });
          }

          // Function to populate the select dropdowns for manual match creation
          function populateManualSelects() {
              // Populate Team A selects with all options
              populateSelect(civSelectA, civs);
              populateSelect(matSelectA, cityMats);

              // Populate Team B selects initially with all options (no exclusion yet)
              populateSelect(civSelectB, civs);
              populateSelect(matSelectB, cityMats);
          }

          // Function to update the match history display
          function updateMatchHistoryDisplay() {
               const historyList = document.getElementById("matchHistory");
               historyList.innerHTML = matchHistory.map((match, index) => { // Added index parameter
                   // Format date only with month in letters
                   const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
                   const date = match.timestamp ? `<span class="match-history-date">${new Date(match.timestamp).toLocaleDateString(undefined, dateOptions)}</span>` : ''; // Format date only, month in letters, wrap in span

                   let historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})`;

                   // Mark winner in bold based on score or tie-breaker
                   if (match.tieBreakerWinner === 'A' || (!match.tieBreakerWinner && match.scoreA > match.scoreB)) {
                       historyDetails = `<span class="match-winner">${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA}</span> - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})`;
                   } else if (match.tieBreakerWinner === 'B' || (!match.tieBreakerWinner && match.scoreA < match.scoreB)) {
                        historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - <span class="match-winner">${match.scoreB} ${match.teamB.civ} (${match.teamB.mat})</span>`;
                   } else {
                        // For pure ties (scoreA === scoreB and no tieBreakerWinner recorded)
                        historyDetails = `${match.teamA.civ} (${match.teamA.mat}) ${match.scoreA} - ${match.scoreB} ${match.teamB.civ} (${match.teamB.mat}) (Tie)`;
                   }

                   // Add the match number
                   const matchNumber = `<span class="match-number">${index + 1}.</span>`;

                   // Wrap history details in a span for flexbox
                   historyDetails = `${matchNumber}<span class="match-history-details">${historyDetails}</span>`;

                   // Combine details and date, with date on the right
                   return `<li>${historyDetails}${date}</li>`;
               }).join('');
          }


          // --- Event Listeners ---

          // Wait for the DOM to be fully loaded before adding event listeners
          document.addEventListener('DOMContentLoaded', () => {
              // Get button elements
              const generateButton = document.getElementById('generateMatchButton');
              const submitButton = document.getElementById('submitScoreButton');
              const resetButton = document.getElementById('resetButton');
              const undoButton = document.getElementById('undoButton');
              const createManualButton = document.getElementById('createManualMatchButton'); // Get manual button
              const fireworksCanvas = document.getElementById('fireworksCanvas'); // Get canvas element
              const scoreButtons = document.querySelectorAll('.score-button'); // Get all score buttons


              // Add click event listeners
              if (generateButton) generateButton.addEventListener('click', handleGenerateRandomMatchClick); // Use the new handler
              if (submitButton) submitButton.addEventListener('click', submitScore);
              if (resetButton) resetButton.addEventListener('click', resetMatches); // Use the new handler for reset
              if (undoButton) undoButton.addEventListener('click', undoLastMatch);
              if (createManualButton) createManualMatchButton.addEventListener('click', createManualMatch); // Add listener for manual button

              // Add event listeners for the custom confirmation modal buttons
              customConfirmOK.addEventListener('click', () => {
                  if (customConfirmCallback) {
                      customConfirmCallback(true); // Pass true for OK
                  }
                  hideCustomConfirm();
              });

              customConfirmCancel.addEventListener('click', () => {
                  if (customConfirmCallback) {
                      customConfirmCallback(false); // Pass false for Cancel
                  }
                  hideCustomConfirm();
              });

              // Add change listeners for manual select elements to exclude selected options from Team B
              civSelectA.addEventListener('change', () => {
                  const selectedCivA = civSelectA.value;
                  populateSelect(civSelectB, civs, selectedCivA);
              });

               matSelectA.addEventListener('change', () => {
                   const selectedMatA = matSelectA.value;
                   populateSelect(matSelectB, cityMats, selectedMatA);
               });

               // Add click listeners to score buttons
               scoreButtons.forEach(button => {
                   button.addEventListener('click', (event) => {
                       const targetInputId = event.target.dataset.target; // Get the target input id from data-target
                       const value = parseInt(event.target.dataset.value); // Get the value to add/subtract
                       const targetInput = document.getElementById(targetInputId); // Get the target input element
                       const operation = event.target.dataset.operation; // Get the operation ('add' or 'subtract')

                       // Ensure targetInput exists and value is a valid number
                       if (targetInput && !isNaN(value)) {
                           let currentValue = parseInt(targetInput.value) || 0; // Get current value (default to 0 if empty or invalid)

                           if (operation === 'add') {
                               currentValue += value;
                           } else if (operation === 'subtract') {
                               currentValue -= value;
                               // Ensure score doesn't go below zero
                               currentValue = Math.max(0, currentValue);
                           }

                           targetInput.value = currentValue; // Update the input
                            console.log(`Clicked ${operation} ${value} for ${targetInputId}. New value: ${targetInput.value}`); // Log for debugging
                       } else {
                           console.log("Score button click failed: target input or value is invalid."); // Log failure
                       }
                   });
               });


              // Add click listener to stop fireworks when clicking on the canvas
              if (fireworksCanvas) {
                  fireworksCanvas.addEventListener('click', stopFireworks);
              }

              // Load data from local storage on page load
              loadData();
              // Update tables and history display based on loaded data
              updateTables();
              updateMatchHistoryDisplay(); // Update history display on load
              // Populate the manual select dropdowns
              populateManualSelects(); // Use the new populate function


              // Make handleTieBreaker globally accessible for onclick in dynamically created buttons
              window.handleTieBreaker = handleTieBreaker;


              // Resize canvas when window is resized
              window.addEventListener('resize', () => {
                  canvas.width = window.innerWidth;
                  canvas.height = window.innerHeight;
                  // Redraw or adjust particles if needed, but clearing is simpler here
              });
          });

      </script>

  </body>
  </html>
  
